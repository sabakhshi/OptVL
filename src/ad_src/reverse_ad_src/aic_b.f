C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.16 (develop) - 22 Aug 2023 15:51
C
C  Differentiation of vvor in reverse (adjoint) mode (with options i4 dr8 r8):
C   gradient     of useful results: chordv rc rv1 rv2 zsym betm
C                ysym wc_gam
C   with respect to varying inputs: chordv rc rv1 rv2 zsym betm
C                ysym wc_gam
C***********************************************************************
C    Module:  aic.f
C 
C    Copyright (C) 2002 Mark Drela, Harold Youngren
C 
C    This program is free software; you can redistribute it and/or modify
C    it under the terms of the GNU General Public License as published by
C    the Free Software Foundation; either version 2 of the License, or
C    (at your option) any later version.
C
C    This program is distributed in the hope that it will be useful,
C    but WITHOUT ANY WARRANTY; without even the implied warranty of
C    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
C    GNU General Public License for more details.
C
C    You should have received a copy of the GNU General Public License
C    along with this program; if not, write to the Free Software
C    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
C***********************************************************************
C
C
      SUBROUTINE VVOR_B(betm, betm_diff, iysym, ysym, ysym_diff, izsym, 
     +                  zsym, zsym_diff, vrcorec, vrcorew, nv, rv1, 
     +                  rv1_diff, rv2, rv2_diff, ncompv, chordv, 
     +                  chordv_diff, nc, rc, rc_diff, ncompc, lvtest, 
     +                  wc_gam, wc_gam_diff, ncdim)
      INCLUDE 'AVL_kinds.INC'
      INTEGER nv
C
      REAL(kind=avl_real) rv1(3, nv), rv2(3, nv), chordv(nv)
      REAL(kind=avl_real) rv1_diff(3, nv), rv2_diff(3, nv), chordv_diff
     +                     (nv)
      INTEGER nc
      INTEGER ncdim
      REAL(kind=avl_real) rc(3, nc), wc_gam(3, ncdim, ncdim)
      REAL(kind=avl_real) rc_diff(3, nc), wc_gam_diff(3, ncdim, ncdim)
      INTEGER ncompv(nv), ncompc(nc)
      LOGICAL lvtest
C     
      LOGICAL lbound
      REAL fysym
      INTRINSIC FLOAT
      REAL fzsym
      INTEGER i
      REAL x
      REAL x_diff
      REAL y
      REAL y_diff
      REAL z
      REAL z_diff
      REAL u
      REAL u_diff
      REAL v
      REAL v_diff
      REAL w
      REAL w_diff
      INTEGER j
      REAL dsyz
      REAL dsyz_diff
      INTRINSIC SQRT
      REAL rcore
      REAL rcore_diff
      INTRINSIC MAX
      REAL ui
      REAL ui_diff
      REAL vi
      REAL vi_diff
      REAL wi
      REAL wi_diff
      REAL yoff
      REAL yoff_diff
      REAL zoff
      REAL zoff_diff
      REAL xave
      REAL yave
      REAL zave
      REAL uii
      REAL uii_diff
      REAL vii
      REAL vii_diff
      REAL wii
      REAL wii_diff
      REAL us
      REAL us_diff
      REAL vs
      REAL vs_diff
      REAL ws
      REAL ws_diff
      REAL(kind=avl_real) arg1
      REAL(kind=avl_real) arg1_diff
      REAL(kind=avl_real) arg2
      REAL(kind=avl_real) arg2_diff
      REAL(kind=avl_real) arg3
      REAL(kind=avl_real) arg3_diff
      REAL(kind=avl_real) arg4
      REAL(kind=avl_real) arg4_diff
      REAL(kind=avl_real) temp
      REAL(kind=avl_real) temp0
      REAL(kind=avl_real) temp_diff
      REAL(kind=avl_real) temp_diff0
      REAL(kind=avl_real) temp_diff1
      INTEGER*4 branch
      REAL vrcorec
      REAL vrcorew
      REAL zsym
      REAL zsym_diff
      INTEGER izsym
      REAL betm
      REAL betm_diff
      REAL ysym
      REAL ysym_diff
      INTEGER iysym
C     
C     
      fysym = FLOAT(iysym)
      fzsym = FLOAT(izsym)
C$BWD-OF II-LOOP 
      DO i=1,nc
C...  Control point location
        x = rc(1, i)
        y = rc(2, i)
        z = rc(3, i)
C     
        x_diff = 0.D0
        y_diff = 0.D0
        z_diff = 0.D0
C$BWD-OF II-LOOP 
        DO j=1,nv
C--------- set vortex core
          dsyz = SQRT((rv2(2, j)-rv1(2, j))**2 + (rv2(3, j)-rv1(3, j))**
     +      2)
C---- default (non-zero) core size based on spanwise lattice spacing
          rcore = 0.0001*dsyz
C---- if field point is not on same component use larger core size
          IF (nc .EQ. nv) THEN
            IF (ncompc(i) .NE. ncompv(j)) THEN
              IF (vrcorec*chordv(j) .LT. vrcorew*dsyz) THEN
                rcore = vrcorew*dsyz
                CALL PUSHCONTROL2B(3)
              ELSE
                rcore = vrcorec*chordv(j)
                CALL PUSHCONTROL2B(2)
              END IF
            ELSE
              CALL PUSHCONTROL2B(0)
            END IF
          ELSE
            CALL PUSHCONTROL2B(1)
          END IF
C     
C     
          yoff = 2.0*ysym
          zoff = 2.0*zsym
CCC   ZOFF = 2.0*(ZSYM + ALFA*0.5*(RV1(1,J)+RV2(1,J)) )
C     
C...  Calculate the influence of the REAL vortex
C
C     
          IF (iysym .NE. 0) THEN
C...  Calculate the influence of the y-IMAGE vortex
            lbound = .true.
C...  For sym/asym matrices check for vortex midpoints of image vortices
            IF (iysym .EQ. 1) THEN
              xave = 0.5*(rv1(1, j)+rv2(1, j))
              yave = yoff - 0.5*(rv1(2, j)+rv2(2, j))
              zave = 0.5*(rv1(3, j)+rv2(3, j))
              IF (x .EQ. xave .AND. y .EQ. yave .AND. z .EQ. zave) THEN
                CALL PUSHCONTROL1B(0)
                lbound = .false.
              ELSE
                CALL PUSHCONTROL1B(0)
              END IF
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
C     
          IF (izsym .NE. 0) THEN
C...  Calculate the influence of the z-IMAGE vortex
            CALL PUSHBOOLEAN(lbound)
C     
C...  Calculate the influence of the y,z-IMAGE vortex
            IF (iysym .NE. 0) THEN
              lbound = .true.
              arg1 = yoff - rv1(2, j)
              arg2 = zoff - rv1(3, j)
              arg3 = yoff - rv2(2, j)
              arg4 = zoff - rv2(3, j)
C     
              CALL PUSHCONTROL2B(0)
            ELSE
              CALL PUSHCONTROL2B(1)
            END IF
          ELSE
            CALL PUSHCONTROL2B(2)
          END IF
          ws_diff = wc_gam_diff(3, i, j)
          wc_gam_diff(3, i, j) = 0.D0
          vs_diff = wc_gam_diff(2, i, j)
          wc_gam_diff(2, i, j) = 0.D0
          us_diff = wc_gam_diff(1, i, j)
          wc_gam_diff(1, i, j) = 0.D0
          w_diff = ws_diff
          wi_diff = ws_diff
          v_diff = vs_diff
          vi_diff = vs_diff
          u_diff = us_diff
          ui_diff = us_diff
          CALL POPCONTROL2B(branch)
          IF (branch .EQ. 0) THEN
            wii_diff = fysym*fzsym*wi_diff
            vii_diff = fysym*fzsym*vi_diff
            uii_diff = fysym*fzsym*ui_diff
            arg1_diff = 0.D0
            arg2_diff = 0.D0
            arg3_diff = 0.D0
            arg4_diff = 0.D0
            rcore_diff = 0.D0
            CALL VORVELC_B(x, x_diff, y, y_diff, z, z_diff, lbound, rv1(
     +                     1, j), rv1_diff(1, j), arg1, arg1_diff, arg2
     +                     , arg2_diff, rv2(1, j), rv2_diff(1, j), arg3
     +                     , arg3_diff, arg4, arg4_diff, betm, betm_diff
     +                     , uii, uii_diff, vii, vii_diff, wii, wii_diff
     +                     , rcore, rcore_diff)
            zoff_diff = arg4_diff + arg2_diff
            rv2_diff(3, j) = rv2_diff(3, j) - arg4_diff
            yoff_diff = arg3_diff + arg1_diff
            rv2_diff(2, j) = rv2_diff(2, j) - arg3_diff
            rv1_diff(3, j) = rv1_diff(3, j) - arg2_diff
            rv1_diff(2, j) = rv1_diff(2, j) - arg1_diff
          ELSE IF (branch .EQ. 1) THEN
            rcore_diff = 0.D0
            zoff_diff = 0.D0
            yoff_diff = 0.D0
          ELSE
            rcore_diff = 0.D0
            zoff_diff = 0.D0
            yoff_diff = 0.D0
            GOTO 100
          END IF
          wii_diff = fzsym*w_diff
          vii_diff = fzsym*v_diff
          uii_diff = fzsym*u_diff
          lbound = .true.
          arg1 = zoff - rv2(3, j)
          arg2 = zoff - rv1(3, j)
          arg1_diff = 0.D0
          arg2_diff = 0.D0
          CALL VORVELC_B(x, x_diff, y, y_diff, z, z_diff, lbound, rv2(1
     +                   , j), rv2_diff(1, j), rv2(2, j), rv2_diff(2, j)
     +                   , arg1, arg1_diff, rv1(1, j), rv1_diff(1, j), 
     +                   rv1(2, j), rv1_diff(2, j), arg2, arg2_diff, 
     +                   betm, betm_diff, uii, uii_diff, vii, vii_diff, 
     +                   wii, wii_diff, rcore, rcore_diff)
          zoff_diff = zoff_diff + arg2_diff + arg1_diff
          rv1_diff(3, j) = rv1_diff(3, j) - arg2_diff
          rv2_diff(3, j) = rv2_diff(3, j) - arg1_diff
          CALL POPBOOLEAN(lbound)
 100      CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            wi_diff = fysym*wi_diff
            vi_diff = fysym*vi_diff
            ui_diff = fysym*ui_diff
            arg1 = yoff - rv2(2, j)
            arg2 = yoff - rv1(2, j)
            arg1_diff = 0.D0
            arg2_diff = 0.D0
            CALL VORVELC_B(x, x_diff, y, y_diff, z, z_diff, lbound, rv2(
     +                     1, j), rv2_diff(1, j), arg1, arg1_diff, rv2(3
     +                     , j), rv2_diff(3, j), rv1(1, j), rv1_diff(1, 
     +                     j), arg2, arg2_diff, rv1(3, j), rv1_diff(3, j
     +                     ), betm, betm_diff, ui, ui_diff, vi, vi_diff
     +                     , wi, wi_diff, rcore, rcore_diff)
            yoff_diff = yoff_diff + arg2_diff + arg1_diff
            rv1_diff(2, j) = rv1_diff(2, j) - arg2_diff
            rv2_diff(2, j) = rv2_diff(2, j) - arg1_diff
            CALL POPCONTROL1B(branch)
          END IF
          lbound = .NOT.(lvtest .AND. i .EQ. j)
          CALL VORVELC_B(x, x_diff, y, y_diff, z, z_diff, lbound, rv1(1
     +                   , j), rv1_diff(1, j), rv1(2, j), rv1_diff(2, j)
     +                   , rv1(3, j), rv1_diff(3, j), rv2(1, j), 
     +                   rv2_diff(1, j), rv2(2, j), rv2_diff(2, j), rv2(
     +                   3, j), rv2_diff(3, j), betm, betm_diff, u, 
     +                   u_diff, v, v_diff, w, w_diff, rcore, rcore_diff
     +                  )
          zsym_diff = zsym_diff + 2.0*zoff_diff
          ysym_diff = ysym_diff + 2.0*yoff_diff
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              dsyz_diff = 0.D0
            ELSE
              dsyz_diff = 0.D0
            END IF
          ELSE
            IF (branch .EQ. 2) THEN
              chordv_diff(j) = chordv_diff(j) + vrcorec*rcore_diff
              dsyz_diff = 0.D0
            ELSE
              dsyz_diff = vrcorew*rcore_diff
            END IF
            rcore_diff = 0.D0
          END IF
          dsyz_diff = dsyz_diff + 0.0001*rcore_diff
          temp = rv2(3, j) - rv1(3, j)
          temp0 = rv2(2, j) - rv1(2, j)
          IF (temp0**2 + temp**2 .EQ. 0.D0) THEN
            temp_diff = 0.D0
          ELSE
            temp_diff = dsyz_diff/(2.0*SQRT(temp0**2+temp**2))
          END IF
          temp_diff0 = 2*temp0*temp_diff
          temp_diff1 = 2*temp*temp_diff
          rv2_diff(3, j) = rv2_diff(3, j) + temp_diff1
          rv1_diff(3, j) = rv1_diff(3, j) - temp_diff1
          rv2_diff(2, j) = rv2_diff(2, j) + temp_diff0
          rv1_diff(2, j) = rv1_diff(2, j) - temp_diff0
        ENDDO
        rc_diff(3, i) = rc_diff(3, i) + z_diff
        rc_diff(2, i) = rc_diff(2, i) + y_diff
        rc_diff(1, i) = rc_diff(1, i) + x_diff
      ENDDO
      END

C  Differentiation of vsrd in reverse (adjoint) mode (with options i4 dr8 r8):
C   gradient     of useful results: wc_u rc src_u
C   with respect to varying inputs: rc rl dbl_u zsym betm ysym
C                src_u
C
C
C
      SUBROUTINE VSRD_B(betm, betm_diff, iysym, ysym, ysym_diff, izsym, 
     +                  zsym, zsym_diff, srcore, nbody, lfrst, nldim, nl
     +                  , rl, rl_diff, radl, nu, src_u, src_u_diff, 
     +                  dbl_u, dbl_u_diff, nc, rc, rc_diff, wc_u, 
     +                  wc_u_diff, ncdim)
C--------------------------------------------------------------------
C     Calculates the velocity influence matrix for a collection 
C     of source+doublet lines
C     
C Input
C -----
C       BETM     SQRT(1-MACH*MACH)
C       IYSYM    Plane of symmetry XZ 
C                 = 0 no symmetry
C                 = 1 regular symmetry
C                 =-1 free-surface symmetry
C       YSYM     Y coordinate of symmetry plane
C       IZSYM    Second plane of symmetry XY 
C                 = 0 no second plane
C                 = 1 regular symmetry
C                 =-1 free-surface symmetry
C       ZSYM     Z coordinate of symmetry plane
C
C       SRCORE   source-line core radius / body radius
C
C       NBODY      number of bodies
C       LFRST(b)   index of first node in body b
C       NLDIM      size of SRC_U, DBL_U matrices
C       NL(b)      number of source-line nodes in each body
C       RL(3,b)    source-line node
C       RADL(b)    body radius at node
C
C       NU         number of apparent-freestream components
C       SRC_U(u)   source  strength per unit freestream component
C       DBL_U(3,u) doublet strength per unit freestream component
C
C       NC        number of control points
C       RC(3,c)   control point node where velocity is evaluated
C
C       NCDIM      size of WC matrix
C          
C Output
C ------
C       WC_U(3,c,u)  velocity per unit freestream
C
C--------------------------------------------------------------------
      INTEGER lfrst(*), nl(*)
      INTEGER nldim
      REAL rl(3, nldim), radl(nldim)
      REAL rl_diff(3, nldim)
      INTEGER nu
      INTEGER ncdim
      REAL src_u(nldim, nu), dbl_u(3, nldim, nu), rc(3, ncdim), wc_u(3, 
     +     ncdim, nu)
      REAL src_u_diff(nldim, nu), dbl_u_diff(3, nldim, nu), rc_diff(3, 
     +     ncdim), wc_u_diff(3, ncdim, nu)
C
C
      REAL vsrc(3), vdbl(3, 3)
      REAL vsrc_diff(3), vdbl_diff(3, 3)
      REAL fysym
      INTRINSIC FLOAT
      REAL fzsym
      REAL yoff
      REAL yoff_diff
      REAL zoff
      REAL zoff_diff
      INTEGER i
      INTEGER iu
      INTEGER ibody
      INTEGER ilseg
      INTEGER l1
      INTEGER l2
      INTEGER l
      REAL ravg
      INTRINSIC SQRT
      REAL rlavg
      REAL rlavg_diff
      REAL rcore
      REAL rcore_diff
      INTEGER k
      REAL arg1
      REAL arg1_diff
      REAL arg2
      REAL arg2_diff
      REAL arg3
      REAL arg3_diff
      REAL arg4
      REAL arg4_diff
      REAL temp
      REAL temp0
      REAL temp1
      REAL temp_diff
      REAL temp_diff0
      REAL temp_diff1
      REAL temp_diff2
      INTEGER*4 branch
      INTEGER ad_to
      INTEGER ii1
      INTEGER ii2
      INTEGER ii3
      INTEGER nc
      INTEGER nbody
      REAL pi
      REAL zsym
      REAL zsym_diff
      REAL srcore
      INTEGER izsym
      REAL betm
      REAL betm_diff
      REAL ysym
      REAL ysym_diff
      INTEGER iysym
      DATA pi /3.14159265/
C
      fysym = FLOAT(iysym)
      fzsym = FLOAT(izsym)
C
      yoff = 2.0*ysym
      zoff = 2.0*zsym
C
C
      DO ibody=1,nbody
        DO ilseg=1,nl(ibody)-1
          l1 = lfrst(ibody) + ilseg - 1
          l2 = lfrst(ibody) + ilseg
C
C
          ravg = SQRT(0.5*(radl(l2)**2+radl(l1)**2))
          rlavg = SQRT((rl(1, l2)-rl(1, l1))**2 + (rl(2, l2)-rl(2, l1))
     +      **2 + (rl(3, l2)-rl(3, l1))**2)
Ccc          print *,'L RAVG, RLAVG ',L,RAVG, RLAVG
          IF (srcore .GT. 0) THEN
            CALL PUSHREAL8(rcore)
            rcore = srcore*ravg
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHREAL8(rcore)
            rcore = srcore*rlavg
            CALL PUSHCONTROL1B(0)
          END IF
C
          DO i=1,nc
C------------------------------------------------------------
C---------- influence of real segment
            CALL PUSHREAL8ARRAY(vdbl, 3**2)
            CALL PUSHREAL8ARRAY(vsrc, 3)
            CALL SRDVELC(rc(1, i), rc(2, i), rc(3, i), rl(1, l1), rl(2, 
     +                   l1), rl(3, l1), rl(1, l2), rl(2, l2), rl(3, l2)
     +                   , betm, rcore, vsrc, vdbl)
C
C------------------------------------------------------------
            IF (iysym .NE. 0) THEN
C----------- influence of y-image
              arg1 = yoff - rl(2, l1)
              arg2 = yoff - rl(2, l2)
              CALL PUSHREAL8ARRAY(vdbl, 3**2)
              CALL PUSHREAL8ARRAY(vsrc, 3)
              CALL SRDVELC(rc(1, i), rc(2, i), rc(3, i), rl(1, l1), arg1
     +                     , rl(3, l1), rl(1, l2), arg2, rl(3, l2), betm
     +                     , rcore, vsrc, vdbl)
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
C
C------------------------------------------------------------
            IF (izsym .NE. 0) THEN
C----------- influence of z-image
              arg1 = zoff - rl(3, l1)
              arg2 = zoff - rl(3, l2)
              CALL PUSHREAL8ARRAY(vdbl, 3**2)
              CALL PUSHREAL8ARRAY(vsrc, 3)
              CALL SRDVELC(rc(1, i), rc(2, i), rc(3, i), rl(1, l1), rl(2
     +                     , l1), arg1, rl(1, l2), rl(2, l2), arg2, betm
     +                     , rcore, vsrc, vdbl)
C
C------------------------------------------------------------
              IF (iysym .NE. 0) THEN
C------------ influence of z-image
                arg1 = yoff - rl(2, l1)
                arg2 = zoff - rl(3, l1)
                arg3 = yoff - rl(2, l2)
                arg4 = zoff - rl(3, l2)
                CALL PUSHREAL8ARRAY(vdbl, 3**2)
                CALL PUSHREAL8ARRAY(vsrc, 3)
                CALL SRDVELC(rc(1, i), rc(2, i), rc(3, i), rl(1, l1), 
     +                       arg1, arg2, rl(1, l2), arg3, arg4, betm, 
     +                       rcore, vsrc, vdbl)
                CALL PUSHCONTROL2B(0)
              ELSE
                CALL PUSHCONTROL2B(1)
              END IF
            ELSE
              CALL PUSHCONTROL2B(2)
            END IF
          ENDDO
        ENDDO
        CALL PUSHINTEGER4(ilseg - 1)
      ENDDO
      DO ii1=1,nldim
        DO ii2=1,3
          rl_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,nu
        DO ii2=1,nldim
          DO ii3=1,3
            dbl_u_diff(ii3, ii2, ii1) = 0.D0
          ENDDO
        ENDDO
      ENDDO
      betm_diff = 0.D0
      zoff_diff = 0.D0
      yoff_diff = 0.D0
      DO ii1=1,3
        DO ii2=1,3
          vdbl_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,3
        vsrc_diff(ii1) = 0.D0
      ENDDO
      DO ibody=nbody,1,-1
        CALL POPINTEGER4(ad_to)
        DO ilseg=ad_to,1,-1
          l1 = lfrst(ibody) + ilseg - 1
          l = l1
          l2 = lfrst(ibody) + ilseg
          rcore_diff = 0.D0
          DO i=nc,1,-1
            CALL POPCONTROL2B(branch)
            IF (branch .EQ. 0) THEN
              DO iu=nu,1,-1
                DO k=3,1,-1
                  temp_diff = fysym*fzsym*wc_u_diff(k, i, iu)
                  vsrc_diff(k) = vsrc_diff(k) + src_u(l, iu)*temp_diff
                  src_u_diff(l, iu) = src_u_diff(l, iu) + vsrc(k)*
     +              temp_diff
                  vdbl_diff(k, 1) = vdbl_diff(k, 1) + dbl_u(1, l, iu)*
     +              temp_diff
                  dbl_u_diff(1, l, iu) = dbl_u_diff(1, l, iu) + vdbl(k, 
     +              1)*temp_diff
                  vdbl_diff(k, 2) = vdbl_diff(k, 2) - dbl_u(2, l, iu)*
     +              temp_diff
                  dbl_u_diff(2, l, iu) = dbl_u_diff(2, l, iu) - vdbl(k, 
     +              2)*temp_diff
                  vdbl_diff(k, 3) = vdbl_diff(k, 3) - dbl_u(3, l, iu)*
     +              temp_diff
                  dbl_u_diff(3, l, iu) = dbl_u_diff(3, l, iu) - vdbl(k, 
     +              3)*temp_diff
                ENDDO
              ENDDO
              arg1 = yoff - rl(2, l1)
              arg2 = zoff - rl(3, l1)
              arg3 = yoff - rl(2, l2)
              arg4 = zoff - rl(3, l2)
              CALL POPREAL8ARRAY(vsrc, 3)
              CALL POPREAL8ARRAY(vdbl, 3**2)
              arg1_diff = 0.D0
              arg2_diff = 0.D0
              arg3_diff = 0.D0
              arg4_diff = 0.D0
              CALL SRDVELC_B(rc(1, i), rc_diff(1, i), rc(2, i), rc_diff(
     +                       2, i), rc(3, i), rc_diff(3, i), rl(1, l1), 
     +                       rl_diff(1, l1), arg1, arg1_diff, arg2, 
     +                       arg2_diff, rl(1, l2), rl_diff(1, l2), arg3
     +                       , arg3_diff, arg4, arg4_diff, betm, 
     +                       betm_diff, rcore, rcore_diff, vsrc, 
     +                       vsrc_diff, vdbl, vdbl_diff)
              zoff_diff = zoff_diff + arg4_diff + arg2_diff
              rl_diff(3, l2) = rl_diff(3, l2) - arg4_diff
              yoff_diff = yoff_diff + arg3_diff + arg1_diff
              rl_diff(2, l2) = rl_diff(2, l2) - arg3_diff
              rl_diff(3, l1) = rl_diff(3, l1) - arg2_diff
              rl_diff(2, l1) = rl_diff(2, l1) - arg1_diff
            ELSE IF (branch .NE. 1) THEN
              GOTO 100
            END IF
            DO iu=nu,1,-1
              DO k=3,1,-1
                temp_diff = fzsym*wc_u_diff(k, i, iu)
                vsrc_diff(k) = vsrc_diff(k) + src_u(l, iu)*temp_diff
                src_u_diff(l, iu) = src_u_diff(l, iu) + vsrc(k)*
     +            temp_diff
                vdbl_diff(k, 1) = vdbl_diff(k, 1) + dbl_u(1, l, iu)*
     +            temp_diff
                dbl_u_diff(1, l, iu) = dbl_u_diff(1, l, iu) + vdbl(k, 1)
     +            *temp_diff
                vdbl_diff(k, 2) = vdbl_diff(k, 2) + dbl_u(2, l, iu)*
     +            temp_diff
                dbl_u_diff(2, l, iu) = dbl_u_diff(2, l, iu) + vdbl(k, 2)
     +            *temp_diff
                vdbl_diff(k, 3) = vdbl_diff(k, 3) - dbl_u(3, l, iu)*
     +            temp_diff
                dbl_u_diff(3, l, iu) = dbl_u_diff(3, l, iu) - vdbl(k, 3)
     +            *temp_diff
              ENDDO
            ENDDO
            arg1 = zoff - rl(3, l1)
            arg2 = zoff - rl(3, l2)
            CALL POPREAL8ARRAY(vsrc, 3)
            CALL POPREAL8ARRAY(vdbl, 3**2)
            arg1_diff = 0.D0
            arg2_diff = 0.D0
            CALL SRDVELC_B(rc(1, i), rc_diff(1, i), rc(2, i), rc_diff(2
     +                     , i), rc(3, i), rc_diff(3, i), rl(1, l1), 
     +                     rl_diff(1, l1), rl(2, l1), rl_diff(2, l1), 
     +                     arg1, arg1_diff, rl(1, l2), rl_diff(1, l2), 
     +                     rl(2, l2), rl_diff(2, l2), arg2, arg2_diff, 
     +                     betm, betm_diff, rcore, rcore_diff, vsrc, 
     +                     vsrc_diff, vdbl, vdbl_diff)
            zoff_diff = zoff_diff + arg2_diff + arg1_diff
            rl_diff(3, l2) = rl_diff(3, l2) - arg2_diff
            rl_diff(3, l1) = rl_diff(3, l1) - arg1_diff
 100        CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              DO iu=nu,1,-1
                DO k=3,1,-1
                  temp_diff = fysym*wc_u_diff(k, i, iu)
                  vsrc_diff(k) = vsrc_diff(k) + src_u(l, iu)*temp_diff
                  src_u_diff(l, iu) = src_u_diff(l, iu) + vsrc(k)*
     +              temp_diff
                  vdbl_diff(k, 1) = vdbl_diff(k, 1) + dbl_u(1, l, iu)*
     +              temp_diff
                  dbl_u_diff(1, l, iu) = dbl_u_diff(1, l, iu) + vdbl(k, 
     +              1)*temp_diff
                  vdbl_diff(k, 3) = vdbl_diff(k, 3) + dbl_u(3, l, iu)*
     +              temp_diff
                  dbl_u_diff(3, l, iu) = dbl_u_diff(3, l, iu) + vdbl(k, 
     +              3)*temp_diff
                  vdbl_diff(k, 2) = vdbl_diff(k, 2) - dbl_u(2, l, iu)*
     +              temp_diff
                  dbl_u_diff(2, l, iu) = dbl_u_diff(2, l, iu) - vdbl(k, 
     +              2)*temp_diff
                ENDDO
              ENDDO
              arg1 = yoff - rl(2, l1)
              arg2 = yoff - rl(2, l2)
              CALL POPREAL8ARRAY(vsrc, 3)
              CALL POPREAL8ARRAY(vdbl, 3**2)
              arg1_diff = 0.D0
              arg2_diff = 0.D0
              CALL SRDVELC_B(rc(1, i), rc_diff(1, i), rc(2, i), rc_diff(
     +                       2, i), rc(3, i), rc_diff(3, i), rl(1, l1), 
     +                       rl_diff(1, l1), arg1, arg1_diff, rl(3, l1)
     +                       , rl_diff(3, l1), rl(1, l2), rl_diff(1, l2)
     +                       , arg2, arg2_diff, rl(3, l2), rl_diff(3, l2
     +                       ), betm, betm_diff, rcore, rcore_diff, vsrc
     +                       , vsrc_diff, vdbl, vdbl_diff)
              yoff_diff = yoff_diff + arg2_diff + arg1_diff
              rl_diff(2, l2) = rl_diff(2, l2) - arg2_diff
              rl_diff(2, l1) = rl_diff(2, l1) - arg1_diff
            END IF
            DO iu=nu,1,-1
              DO k=3,1,-1
                vsrc_diff(k) = vsrc_diff(k) + src_u(l, iu)*wc_u_diff(k, 
     +            i, iu)
                src_u_diff(l, iu) = src_u_diff(l, iu) + vsrc(k)*
     +            wc_u_diff(k, i, iu)
                vdbl_diff(k, 1) = vdbl_diff(k, 1) + dbl_u(1, l, iu)*
     +            wc_u_diff(k, i, iu)
                dbl_u_diff(1, l, iu) = dbl_u_diff(1, l, iu) + vdbl(k, 1)
     +            *wc_u_diff(k, i, iu)
                vdbl_diff(k, 2) = vdbl_diff(k, 2) + dbl_u(2, l, iu)*
     +            wc_u_diff(k, i, iu)
                dbl_u_diff(2, l, iu) = dbl_u_diff(2, l, iu) + vdbl(k, 2)
     +            *wc_u_diff(k, i, iu)
                vdbl_diff(k, 3) = vdbl_diff(k, 3) + dbl_u(3, l, iu)*
     +            wc_u_diff(k, i, iu)
                dbl_u_diff(3, l, iu) = dbl_u_diff(3, l, iu) + vdbl(k, 3)
     +            *wc_u_diff(k, i, iu)
              ENDDO
            ENDDO
            CALL POPREAL8ARRAY(vsrc, 3)
            CALL POPREAL8ARRAY(vdbl, 3**2)
            CALL SRDVELC_B(rc(1, i), rc_diff(1, i), rc(2, i), rc_diff(2
     +                     , i), rc(3, i), rc_diff(3, i), rl(1, l1), 
     +                     rl_diff(1, l1), rl(2, l1), rl_diff(2, l1), rl
     +                     (3, l1), rl_diff(3, l1), rl(1, l2), rl_diff(1
     +                     , l2), rl(2, l2), rl_diff(2, l2), rl(3, l2), 
     +                     rl_diff(3, l2), betm, betm_diff, rcore, 
     +                     rcore_diff, vsrc, vsrc_diff, vdbl, vdbl_diff)
          ENDDO
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREAL8(rcore)
            rlavg_diff = srcore*rcore_diff
          ELSE
            CALL POPREAL8(rcore)
            rlavg_diff = 0.D0
          END IF
          temp = rl(3, l2) - rl(3, l1)
          temp0 = rl(2, l2) - rl(2, l1)
          temp1 = rl(1, l2) - rl(1, l1)
          IF (temp1**2 + temp0**2 + temp**2 .EQ. 0.D0) THEN
            temp_diff = 0.D0
          ELSE
            temp_diff = rlavg_diff/(2.0*SQRT(temp1**2+temp0**2+temp**2))
          END IF
          temp_diff0 = 2*temp1*temp_diff
          temp_diff1 = 2*temp0*temp_diff
          temp_diff2 = 2*temp*temp_diff
          rl_diff(3, l2) = rl_diff(3, l2) + temp_diff2
          rl_diff(3, l1) = rl_diff(3, l1) - temp_diff2
          rl_diff(2, l2) = rl_diff(2, l2) + temp_diff1
          rl_diff(2, l1) = rl_diff(2, l1) - temp_diff1
          rl_diff(1, l2) = rl_diff(1, l2) + temp_diff0
          rl_diff(1, l1) = rl_diff(1, l1) - temp_diff0
        ENDDO
      ENDDO
      zsym_diff = 2.0*zoff_diff
      ysym_diff = 2.0*yoff_diff
      END

C  Differentiation of srdset in reverse (adjoint) mode (with options i4 dr8 r8):
C   gradient     of useful results: rl xyzref dbl_u betm src_u
C   with respect to varying inputs: rl xyzref betm src_u
C VSRD
C
C
C
      SUBROUTINE SRDSET_B(betm, betm_diff, xyzref, xyzref_diff, iysym, 
     +                    nbody, lfrst, nldim, numax, nl, rl, rl_diff, 
     +                    radl, src_u, src_u_diff, dbl_u, dbl_u_diff)
C----------------------------------------------------------
C     Sets strengths of source+doublet line segments
C     for 6 "unit" flow components consisting of:
C     3 unit (X,Y,Z) freestream and 3 unit (X,Y,Z) rotations
C
C Input
C -----
C       BETM     SQRT(1-MACH*MACH)
C
C       NBODY      number of bodies
C       LFRST(b)   index of first node in body b
C       NLDIM      size of SRC_U, DBL_U matrices
C       NUMAX      outer size of SRC_U, DBL_U matrices
C       NL(b)      number of source-line nodes in each body
C       RL(3,b)    source-line node
C       RADL(b)    body radius at node
C
C Output
C ------
C       SRC_U(u)   source  strength per unit freestream component
C       DBL_U(3,u) doublet strength per unit freestream component
C
C----------------------------------------------------------
      REAL xyzref(3)
      REAL xyzref_diff(3)
      INTEGER nldim
      REAL rl(3, nldim), radl(nldim)
      REAL rl_diff(3, nldim)
      INTEGER lfrst(*), nl(*), iysym
      INTEGER numax
      REAL src_u(nldim, numax), dbl_u(3, nldim, numax)
      REAL src_u_diff(nldim, numax), dbl_u_diff(3, nldim, numax)
C
C
      REAL drl(3), vsrc(3), vdbl(3, 3)
      REAL drl_diff(3)
      REAL esl(3), un(3)
      REAL esl_diff(3), un_diff(3)
      REAL wrot(3), urel(3), rlref(3)
      REAL wrot_diff(3), urel_diff(3), rlref_diff(3)
      INTEGER ibody
      INTEGER l1
      INTEGER l2
      REAL blen
      INTRINSIC ABS
      REAL sdfac
      INTEGER ilseg
      INTEGER l
      REAL drlmag
      REAL drlmag_diff
      INTRINSIC SQRT
      REAL drlmi
      REAL drlmi_diff
      REAL adel
      REAL aavg
      INTEGER iu
      REAL us
      REAL us_diff
      REAL DOT
      REAL temp_diff
      INTEGER ii1
      INTEGER*4 branch
      INTEGER ad_to
      INTEGER nbody
      REAL pi
      REAL betm
      REAL betm_diff
C
      DATA pi /3.14159265/
C
      DO ibody=1,nbody
C
C-------check for body on symmetry plane with Y symmetry
        l1 = lfrst(ibody)
        l2 = l1 + nl(ibody)
        IF (rl(1, l2) - rl(1, l1) .GE. 0.) THEN
          blen = rl(1, l2) - rl(1, l1)
        ELSE
          blen = -(rl(1, l2)-rl(1, l1))
        END IF
        IF (iysym .EQ. 1 .AND. rl(2, l1) .LE. 0.001*blen) THEN
C------- body y-image will be added on, so use only half the area
          sdfac = 0.5
        ELSE
C------- no y-image, so use entire area
          sdfac = 1.0
        END IF
Ccc        print *,'IYSYM,SDFAC ',IYSYM,SDFAC
C            
        DO ilseg=1,nl(ibody)-1
          l1 = lfrst(ibody) + ilseg - 1
          l2 = lfrst(ibody) + ilseg
C
C
          CALL PUSHREAL8(drl(1))
          drl(1) = (rl(1, l2)-rl(1, l1))/betm
          CALL PUSHREAL8(drl(2))
          drl(2) = rl(2, l2) - rl(2, l1)
          CALL PUSHREAL8(drl(3))
          drl(3) = rl(3, l2) - rl(3, l1)
          CALL PUSHREAL8(drlmag)
          drlmag = SQRT(drl(1)**2 + drl(2)**2 + drl(3)**2)
          IF (drlmag .EQ. 0.0) THEN
            CALL PUSHREAL8(drlmi)
            drlmi = 0.0
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHREAL8(drlmi)
            drlmi = 1.0/drlmag
            CALL PUSHCONTROL1B(1)
          END IF
C
C-------- unit vector along line segment
          CALL PUSHREAL8(esl(1))
          esl(1) = drl(1)*drlmi
          CALL PUSHREAL8(esl(2))
          esl(2) = drl(2)*drlmi
          CALL PUSHREAL8(esl(3))
          esl(3) = drl(3)*drlmi
C
          CALL PUSHREAL8(adel)
          adel = pi*(radl(l2)**2-radl(l1)**2)*sdfac
          CALL PUSHREAL8(aavg)
          aavg = pi*0.5*(radl(l2)**2+radl(l1)**2)*sdfac
C
          CALL PUSHREAL8(rlref(1))
          rlref(1) = 0.5*(rl(1, l2)+rl(1, l1)) - xyzref(1)
          CALL PUSHREAL8(rlref(2))
          rlref(2) = 0.5*(rl(2, l2)+rl(2, l1)) - xyzref(2)
          CALL PUSHREAL8(rlref(3))
          rlref(3) = 0.5*(rl(3, l2)+rl(3, l1)) - xyzref(3)
C
C-------- go over freestream velocity and rotation components
          DO iu=1,6
            CALL PUSHREAL8(urel(1))
            urel(1) = 0.
            CALL PUSHREAL8(urel(2))
            urel(2) = 0.
            CALL PUSHREAL8(urel(3))
            urel(3) = 0.
            CALL PUSHREAL8(wrot(1))
            wrot(1) = 0.
            CALL PUSHREAL8(wrot(2))
            wrot(2) = 0.
            CALL PUSHREAL8(wrot(3))
            wrot(3) = 0.
C
            IF (iu .LE. 3) THEN
              CALL PUSHREAL8(urel(iu))
              urel(iu) = 1.0
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHREAL8(wrot(iu-3))
              wrot(iu-3) = 1.0
              CALL PUSHREAL8ARRAY(urel, 3)
              CALL CROSS(rlref, wrot, urel)
              CALL PUSHCONTROL1B(1)
            END IF
            CALL PUSHREAL8(urel(1))
            urel(1) = urel(1)/betm
C
C---------- U.es
            CALL PUSHREAL8(us)
            us = DOT(urel, esl)
C
C---------- velocity projected on normal plane = U - (U.es) es
            CALL PUSHREAL8(un(1))
            un(1) = urel(1) - us*esl(1)
            CALL PUSHREAL8(un(2))
            un(2) = urel(2) - us*esl(2)
            CALL PUSHREAL8(un(3))
            un(3) = urel(3) - us*esl(3)
C
C---------- total source and doublet strength of segment
          ENDDO
        ENDDO
        CALL PUSHINTEGER4(ilseg - 1)
      ENDDO
      DO ii1=1,3
        rlref_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        esl_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        un_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        urel_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        drl_diff(ii1) = 0.D0
      ENDDO
      DO ibody=nbody,1,-1
        CALL POPINTEGER4(ad_to)
        DO ilseg=ad_to,1,-1
          l1 = lfrst(ibody) + ilseg - 1
          l = l1
          drlmag_diff = 0.D0
          DO iu=6,1,-1
            temp_diff = aavg*2.0*dbl_u_diff(3, l, iu)
            dbl_u_diff(3, l, iu) = 0.D0
            un_diff(3) = un_diff(3) + drlmag*temp_diff
            drlmag_diff = drlmag_diff + un(3)*temp_diff
            temp_diff = aavg*2.0*dbl_u_diff(2, l, iu)
            dbl_u_diff(2, l, iu) = 0.D0
            un_diff(2) = un_diff(2) + drlmag*temp_diff
            drlmag_diff = drlmag_diff + un(2)*temp_diff
            temp_diff = aavg*2.0*dbl_u_diff(1, l, iu)
            dbl_u_diff(1, l, iu) = 0.D0
            un_diff(1) = un_diff(1) + drlmag*temp_diff
            drlmag_diff = drlmag_diff + un(1)*temp_diff
            us_diff = adel*src_u_diff(l, iu) - esl(3)*un_diff(3) - esl(2
     +        )*un_diff(2) - esl(1)*un_diff(1)
            src_u_diff(l, iu) = 0.D0
            CALL POPREAL8(un(3))
            urel_diff(3) = urel_diff(3) + un_diff(3)
            esl_diff(3) = esl_diff(3) - us*un_diff(3)
            un_diff(3) = 0.D0
            CALL POPREAL8(un(2))
            urel_diff(2) = urel_diff(2) + un_diff(2)
            esl_diff(2) = esl_diff(2) - us*un_diff(2)
            un_diff(2) = 0.D0
            CALL POPREAL8(un(1))
            urel_diff(1) = urel_diff(1) + un_diff(1)
            esl_diff(1) = esl_diff(1) - us*un_diff(1)
            un_diff(1) = 0.D0
            CALL POPREAL8(us)
            CALL DOT_B(urel, urel_diff, esl, esl_diff, us_diff)
            CALL POPREAL8(urel(1))
            betm_diff = betm_diff - urel(1)*urel_diff(1)/betm**2
            urel_diff(1) = urel_diff(1)/betm
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              CALL POPREAL8(urel(iu))
              urel_diff(iu) = 0.D0
            ELSE
              CALL POPREAL8ARRAY(urel, 3)
              DO ii1=1,3
                wrot_diff(ii1) = 0.D0
              ENDDO
              CALL CROSS_B(rlref, rlref_diff, wrot, wrot_diff, urel, 
     +                     urel_diff)
              CALL POPREAL8(wrot(iu-3))
            END IF
            CALL POPREAL8(wrot(3))
            CALL POPREAL8(wrot(2))
            CALL POPREAL8(wrot(1))
            CALL POPREAL8(urel(3))
            urel_diff(3) = 0.D0
            CALL POPREAL8(urel(2))
            urel_diff(2) = 0.D0
            CALL POPREAL8(urel(1))
            urel_diff(1) = 0.D0
          ENDDO
          l2 = lfrst(ibody) + ilseg
          CALL POPREAL8(rlref(3))
          rl_diff(3, l2) = rl_diff(3, l2) + 0.5*rlref_diff(3)
          rl_diff(3, l1) = rl_diff(3, l1) + 0.5*rlref_diff(3)
          xyzref_diff(3) = xyzref_diff(3) - rlref_diff(3)
          rlref_diff(3) = 0.D0
          CALL POPREAL8(rlref(2))
          rl_diff(2, l2) = rl_diff(2, l2) + 0.5*rlref_diff(2)
          rl_diff(2, l1) = rl_diff(2, l1) + 0.5*rlref_diff(2)
          xyzref_diff(2) = xyzref_diff(2) - rlref_diff(2)
          rlref_diff(2) = 0.D0
          CALL POPREAL8(rlref(1))
          rl_diff(1, l2) = rl_diff(1, l2) + 0.5*rlref_diff(1)
          rl_diff(1, l1) = rl_diff(1, l1) + 0.5*rlref_diff(1)
          xyzref_diff(1) = xyzref_diff(1) - rlref_diff(1)
          rlref_diff(1) = 0.D0
          CALL POPREAL8(aavg)
          CALL POPREAL8(adel)
          CALL POPREAL8(esl(3))
          drl_diff(3) = drl_diff(3) + drlmi*esl_diff(3)
          drlmi_diff = drl(3)*esl_diff(3) + drl(2)*esl_diff(2) + drl(1)*
     +      esl_diff(1)
          esl_diff(3) = 0.D0
          CALL POPREAL8(esl(2))
          drl_diff(2) = drl_diff(2) + drlmi*esl_diff(2)
          esl_diff(2) = 0.D0
          CALL POPREAL8(esl(1))
          drl_diff(1) = drl_diff(1) + drlmi*esl_diff(1)
          esl_diff(1) = 0.D0
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREAL8(drlmi)
          ELSE
            CALL POPREAL8(drlmi)
            drlmag_diff = drlmag_diff - drlmi_diff/drlmag**2
          END IF
          CALL POPREAL8(drlmag)
          IF (drl(1)**2 + drl(2)**2 + drl(3)**2 .EQ. 0.D0) THEN
            temp_diff = 0.D0
          ELSE
            temp_diff = drlmag_diff/(2.0*SQRT(drl(1)**2+drl(2)**2+drl(3)
     +        **2))
          END IF
          drl_diff(1) = drl_diff(1) + 2*drl(1)*temp_diff
          drl_diff(2) = drl_diff(2) + 2*drl(2)*temp_diff
          drl_diff(3) = drl_diff(3) + 2*drl(3)*temp_diff
          CALL POPREAL8(drl(3))
          rl_diff(3, l2) = rl_diff(3, l2) + drl_diff(3)
          rl_diff(3, l1) = rl_diff(3, l1) - drl_diff(3)
          drl_diff(3) = 0.D0
          CALL POPREAL8(drl(2))
          rl_diff(2, l2) = rl_diff(2, l2) + drl_diff(2)
          rl_diff(2, l1) = rl_diff(2, l1) - drl_diff(2)
          drl_diff(2) = 0.D0
          CALL POPREAL8(drl(1))
          temp_diff = drl_diff(1)/betm
          drl_diff(1) = 0.D0
          rl_diff(1, l2) = rl_diff(1, l2) + temp_diff
          rl_diff(1, l1) = rl_diff(1, l1) - temp_diff
          betm_diff = betm_diff - (rl(1, l2)-rl(1, l1))*temp_diff/betm
        ENDDO
      ENDDO
      END

C  Differentiation of cross in reverse (adjoint) mode (with options i4 dr8 r8):
C   gradient     of useful results: u v w
C   with respect to varying inputs: u v w
C SRDSET
C
      SUBROUTINE CROSS_B(u, u_diff, v, v_diff, w, w_diff)
      REAL u(3), v(3), w(3)
      REAL u_diff(3), v_diff(3), w_diff(3)
      u_diff(1) = u_diff(1) + v(2)*w_diff(3) - v(3)*w_diff(2)
      v_diff(2) = v_diff(2) + u(1)*w_diff(3) - u(3)*w_diff(1)
      u_diff(2) = u_diff(2) + v(3)*w_diff(1) - v(1)*w_diff(3)
      v_diff(1) = v_diff(1) + u(3)*w_diff(2) - u(2)*w_diff(3)
      w_diff(3) = 0.D0
      u_diff(3) = u_diff(3) + v(1)*w_diff(2) - v(2)*w_diff(1)
      v_diff(3) = v_diff(3) + u(2)*w_diff(1) - u(1)*w_diff(2)
      w_diff(2) = 0.D0
      w_diff(1) = 0.D0
      END

C  Differentiation of dot in reverse (adjoint) mode (with options i4 dr8 r8):
C   gradient     of useful results: u v dot
C   with respect to varying inputs: u v
C
C
      SUBROUTINE DOT_B(u, u_diff, v, v_diff, dot_diff)
      REAL u(3), v(3)
      REAL u_diff(3), v_diff(3)
      REAL dot
      REAL dot_diff
      u_diff(1) = u_diff(1) + v(1)*dot_diff
      v_diff(1) = v_diff(1) + u(1)*dot_diff
      u_diff(2) = u_diff(2) + v(2)*dot_diff
      v_diff(2) = v_diff(2) + u(2)*dot_diff
      u_diff(3) = u_diff(3) + v(3)*dot_diff
      v_diff(3) = v_diff(3) + u(3)*dot_diff
      END

C  Differentiation of vorvelc in reverse (adjoint) mode (with options i4 dr8 r8):
C   gradient     of useful results: y1 y2 rcore u v w x y z z1
C                z2 x1 x2 beta
C   with respect to varying inputs: y1 y2 rcore x y z z1 z2 x1
C                x2 beta
C
C
      SUBROUTINE VORVELC_B(x, x_diff, y, y_diff, z, z_diff, lbound, x1, 
     +                     x1_diff, y1, y1_diff, z1, z1_diff, x2, 
     +                     x2_diff, y2, y2_diff, z2, z2_diff, beta, 
     +                     beta_diff, u, u_diff, v, v_diff, w, w_diff, 
     +                     rcore, rcore_diff)
C----------------------------------------------------------
C     Same as VORVEL, with finite core radius
C     Original Scully (AKA Burnham-Hallock) core model 
C       Vtan = Gam/2*pi . r/(r^2 +rcore^2)
C      
C     Uses Leishman's R^4 variant of Scully (AKA Burnham-Hallock) core model 
C       Vtan = Gam/2*pi . r/sqrt(r^4 +rcore^4)
C----------------------------------------------------------
      LOGICAL lbound
C
C
      REAL a(3), b(3), axb(3)
      REAL a_diff(3), b_diff(3), axb_diff(3)
      REAL asq
      REAL asq_diff
      REAL bsq
      REAL bsq_diff
      REAL amag
      REAL amag_diff
      INTRINSIC SQRT
      REAL bmag
      REAL bmag_diff
      REAL rcore2
      REAL rcore2_diff
      REAL rcore4
      REAL rcore4_diff
      REAL axbsq
      REAL axbsq_diff
      REAL adb
      REAL adb_diff
      REAL alsq
      REAL alsq_diff
      REAL abmag
      REAL t
      REAL t_diff
      REAL axisq
      REAL axisq_diff
      REAL adx
      REAL adx_diff
      REAL rsq
      REAL rsq_diff
      REAL bxisq
      REAL bxisq_diff
      REAL bdx
      REAL bdx_diff
      REAL temp
      REAL temp_diff
      REAL temp0
      REAL temp_diff0
      REAL temp1
      REAL temp2
      REAL temp3
      REAL temp_diff1
      REAL temp_diff2
      REAL temp4
      REAL temp5
      REAL temp6
      REAL temp_diff3
      REAL temp7
      REAL temp_diff4
      INTEGER ii1
      REAL temp_diff5
      INTEGER*4 branch
      REAL y1
      REAL y1_diff
      REAL y2
      REAL y2_diff
      REAL rcore
      REAL rcore_diff
      REAL u
      REAL u_diff
      REAL v
      REAL v_diff
      REAL w
      REAL w_diff
      REAL x
      REAL x_diff
      REAL y
      REAL y_diff
      REAL z
      REAL z_diff
      REAL z1
      REAL z1_diff
      REAL z2
      REAL z2_diff
      REAL x1
      REAL x1_diff
      REAL x2
      REAL x2_diff
      REAL beta
      REAL beta_diff
      REAL pi4inv
C
      DATA pi4inv /0.079577472/
C
C---- Prandtl-Glauert coordinates 
      a(1) = (x1-x)/beta
      a(2) = y1 - y
      a(3) = z1 - z
C
      b(1) = (x2-x)/beta
      b(2) = y2 - y
      b(3) = z2 - z
C
      asq = a(1)**2 + a(2)**2 + a(3)**2
      bsq = b(1)**2 + b(2)**2 + b(3)**2
C
      amag = SQRT(asq)
      bmag = SQRT(bsq)
C
      rcore2 = rcore**2
      rcore4 = rcore2**2
C
      u = 0.
C
C---- contribution from the transverse bound leg
      IF (lbound .AND. amag*bmag .NE. 0.0) THEN
        axb(1) = a(2)*b(3) - a(3)*b(2)
        axb(2) = a(3)*b(1) - a(1)*b(3)
        axb(3) = a(1)*b(2) - a(2)*b(1)
        axbsq = axb(1)**2 + axb(2)**2 + axb(3)**2
C
        IF (axbsq .NE. 0.0) THEN
          adb = a(1)*b(1) + a(2)*b(2) + a(3)*b(3)
          alsq = asq + bsq - 2.0*adb
Cc c     RSQ = AXBSQ / ALSQ
C     
C---- Scully core model      
Cccc        T = (AMAG+BMAG)*(1.0 - ADB/ABMAG) / (AXBSQ + ALSQ*RCORE2)
Cc        T = (  (BSQ-ADB)/SQRT(BSQ+RCORE2)
Cc     &       + (ASQ-ADB)/SQRT(ASQ+RCORE2) ) / (AXBSQ + ALSQ*RCORE2)
C---- Leishman core model
          t = ((bsq-adb)/SQRT(SQRT(bsq**2+rcore4))+(asq-adb)/SQRT(SQRT(
     +      asq**2+rcore4)))/SQRT(axbsq**2+alsq**2*rcore4)
C
          u = axb(1)*t
          CALL PUSHCONTROL2B(0)
        ELSE
          CALL PUSHCONTROL2B(1)
        END IF
      ELSE
        CALL PUSHCONTROL2B(2)
      END IF
C
C---- trailing leg attached to A
      IF (amag .NE. 0.0) THEN
        axisq = a(3)**2 + a(2)**2
        adx = a(1)
        rsq = axisq
C
C---- Scully core model      
Cc        T = - (1.0 - ADX/AMAG) / (RSQ + RCORE2)
C---- Leishman core model
        CALL PUSHREAL8(t)
        t = -((1.0-adx/amag)/SQRT(rsq**2+rcore4))
C
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
C
C---- trailing leg attached to B
      IF (bmag .NE. 0.0) THEN
        bxisq = b(3)**2 + b(2)**2
        bdx = b(1)
        rsq = bxisq
C
C---- Scully core model      
Cc        T =   (1.0 - BDX/BMAG) / (RSQ + RCORE2)
C---- Leishman core modeld
        CALL PUSHREAL8(t)
        t = (1.0-bdx/bmag)/SQRT(rsq**2+rcore4)
C
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      w_diff = pi4inv*w_diff
      v_diff = pi4inv*v_diff
      temp_diff4 = pi4inv*u_diff/beta
      u_diff = temp_diff4
      beta_diff = beta_diff - u*temp_diff4/beta
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        t_diff = b(3)*v_diff - b(2)*w_diff
        temp7 = SQRT(rsq*rsq + rcore4)
        temp_diff3 = t_diff/temp7
        IF (rsq**2 + rcore4 .EQ. 0.D0) THEN
          temp_diff5 = 0.D0
        ELSE
          temp_diff5 = -((1.0-bdx/bmag)*temp_diff3/(2.0*temp7**2))
        END IF
        rsq_diff = 2*rsq*temp_diff5
        bxisq_diff = rsq_diff
        DO ii1=1,3
          b_diff(ii1) = 0.D0
        ENDDO
        b_diff(2) = b_diff(2) + 2*b(2)*bxisq_diff - t*w_diff
        b_diff(3) = b_diff(3) + t*v_diff + 2*b(3)*bxisq_diff
        CALL POPREAL8(t)
        bdx_diff = -(temp_diff3/bmag)
        bmag_diff = bdx*temp_diff3/bmag**2
        rcore4_diff = temp_diff5
        b_diff(1) = b_diff(1) + bdx_diff
      ELSE
        rcore4_diff = 0.D0
        bmag_diff = 0.D0
        DO ii1=1,3
          b_diff(ii1) = 0.D0
        ENDDO
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        t_diff = a(3)*v_diff - a(2)*w_diff
        rsq = axisq
        temp7 = SQRT(rsq*rsq + rcore4)
        temp_diff3 = -(t_diff/temp7)
        IF (rsq**2 + rcore4 .EQ. 0.D0) THEN
          temp_diff5 = 0.D0
        ELSE
          temp_diff5 = -((1.0-adx/amag)*temp_diff3/(2.0*temp7**2))
        END IF
        rsq_diff = 2*rsq*temp_diff5
        axisq_diff = rsq_diff
        DO ii1=1,3
          a_diff(ii1) = 0.D0
        ENDDO
        a_diff(2) = a_diff(2) + 2*a(2)*axisq_diff - t*w_diff
        a_diff(3) = a_diff(3) + t*v_diff + 2*a(3)*axisq_diff
        CALL POPREAL8(t)
        adx_diff = -(temp_diff3/amag)
        amag_diff = adx*temp_diff3/amag**2
        rcore4_diff = rcore4_diff + temp_diff5
        a_diff(1) = a_diff(1) + adx_diff
      ELSE
        amag_diff = 0.D0
        DO ii1=1,3
          a_diff(ii1) = 0.D0
        ENDDO
      END IF
      CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        DO ii1=1,3
          axb_diff(ii1) = 0.D0
        ENDDO
        axb_diff(3) = axb_diff(3) + t*w_diff
        t_diff = axb(3)*w_diff + axb(2)*v_diff + axb(1)*u_diff
        axb_diff(2) = axb_diff(2) + t*v_diff
        axb_diff(1) = axb_diff(1) + t*u_diff
        temp = axbsq*axbsq + alsq*alsq*rcore4
        temp0 = SQRT(temp)
        temp1 = SQRT(bsq*bsq + rcore4)
        temp2 = SQRT(temp1)
        temp3 = (bsq-adb)/temp2
        temp4 = SQRT(asq*asq + rcore4)
        temp5 = SQRT(temp4)
        temp6 = (asq-adb)/temp5
        temp_diff0 = t_diff/temp0
        temp_diff1 = temp_diff0/temp2
        temp_diff3 = temp_diff0/temp5
        IF (temp .EQ. 0.D0) THEN
          temp_diff = 0.D0
        ELSE
          temp_diff = -((temp3+temp6)*temp_diff0/(2.0*temp0**2))
        END IF
        axbsq_diff = 2*axbsq*temp_diff
        alsq_diff = 2*alsq*rcore4*temp_diff
        adb_diff = -temp_diff3 - temp_diff1 - 2.0*alsq_diff
        IF (asq**2 + rcore4 .EQ. 0.D0 .OR. temp4 .EQ. 0.D0) THEN
          temp_diff4 = 0.D0
        ELSE
          temp_diff4 = -(temp6*temp_diff3/(2.0**2*temp4*temp5))
        END IF
        asq_diff = temp_diff3 + 2*asq*temp_diff4 + alsq_diff
        IF (bsq**2 + rcore4 .EQ. 0.D0 .OR. temp1 .EQ. 0.D0) THEN
          temp_diff2 = 0.D0
        ELSE
          temp_diff2 = -(temp3*temp_diff1/(2.0**2*temp1*temp2))
        END IF
        rcore4_diff = rcore4_diff + alsq**2*temp_diff + temp_diff4 + 
     +    temp_diff2
        bsq_diff = temp_diff1 + 2*bsq*temp_diff2 + alsq_diff
        a_diff(1) = a_diff(1) + b(1)*adb_diff
        b_diff(1) = b_diff(1) + a(1)*adb_diff
        a_diff(2) = a_diff(2) + b(2)*adb_diff
        b_diff(2) = b_diff(2) + a(2)*adb_diff
        a_diff(3) = a_diff(3) + b(3)*adb_diff
        b_diff(3) = b_diff(3) + a(3)*adb_diff
      ELSE IF (branch .EQ. 1) THEN
        axbsq_diff = 0.D0
        DO ii1=1,3
          axb_diff(ii1) = 0.D0
        ENDDO
        bsq_diff = 0.D0
        asq_diff = 0.D0
      ELSE
        bsq_diff = 0.D0
        asq_diff = 0.D0
        GOTO 100
      END IF
      axb_diff(1) = axb_diff(1) + 2*axb(1)*axbsq_diff
      axb_diff(2) = axb_diff(2) + 2*axb(2)*axbsq_diff
      axb_diff(3) = axb_diff(3) + 2*axb(3)*axbsq_diff
      a_diff(1) = a_diff(1) + b(2)*axb_diff(3) - b(3)*axb_diff(2)
      b_diff(2) = b_diff(2) + a(1)*axb_diff(3) - a(3)*axb_diff(1)
      a_diff(2) = a_diff(2) + b(3)*axb_diff(1) - b(1)*axb_diff(3)
      b_diff(1) = b_diff(1) + a(3)*axb_diff(2) - a(2)*axb_diff(3)
      axb_diff(3) = 0.D0
      a_diff(3) = a_diff(3) + b(1)*axb_diff(2) - b(2)*axb_diff(1)
      b_diff(3) = b_diff(3) + a(2)*axb_diff(1) - a(1)*axb_diff(2)
      axb_diff(2) = 0.D0
 100  rcore2_diff = 2*rcore2*rcore4_diff
      rcore_diff = rcore_diff + 2*rcore*rcore2_diff
      IF (.NOT.bsq .EQ. 0.D0) bsq_diff = bsq_diff + bmag_diff/(2.0*SQRT(
     +    bsq))
      IF (.NOT.asq .EQ. 0.D0) asq_diff = asq_diff + amag_diff/(2.0*SQRT(
     +    asq))
      b_diff(1) = b_diff(1) + 2*b(1)*bsq_diff
      b_diff(2) = b_diff(2) + 2*b(2)*bsq_diff
      b_diff(3) = b_diff(3) + 2*b(3)*bsq_diff
      a_diff(1) = a_diff(1) + 2*a(1)*asq_diff
      a_diff(2) = a_diff(2) + 2*a(2)*asq_diff
      a_diff(3) = a_diff(3) + 2*a(3)*asq_diff
      z2_diff = z2_diff + b_diff(3)
      z_diff = z_diff - b_diff(3) - a_diff(3)
      b_diff(3) = 0.D0
      y2_diff = y2_diff + b_diff(2)
      y_diff = y_diff - b_diff(2) - a_diff(2)
      b_diff(2) = 0.D0
      temp_diff = b_diff(1)/beta
      x2_diff = x2_diff + temp_diff
      x_diff = x_diff - temp_diff
      beta_diff = beta_diff - (x2-x)*temp_diff/beta
      z1_diff = z1_diff + a_diff(3)
      a_diff(3) = 0.D0
      y1_diff = y1_diff + a_diff(2)
      a_diff(2) = 0.D0
      temp_diff = a_diff(1)/beta
      x1_diff = x1_diff + temp_diff
      x_diff = x_diff - temp_diff
      beta_diff = beta_diff - (x1-x)*temp_diff/beta
      END

C  Differentiation of srdvelc in reverse (adjoint) mode (with options i4 dr8 r8):
C   gradient     of useful results: y1 y2 rcore x y z z1 z2 uvwd
C                uvws x1 x2 beta
C   with respect to varying inputs: y1 y2 rcore x y z z1 z2 uvwd
C                uvws x1 x2 beta
C VORVELC
C
C
      SUBROUTINE SRDVELC_B(x, x_diff, y, y_diff, z, z_diff, x1, x1_diff
     +                     , y1, y1_diff, z1, z1_diff, x2, x2_diff, y2, 
     +                     y2_diff, z2, z2_diff, beta, beta_diff, rcore
     +                     , rcore_diff, uvws, uvws_diff, uvwd, 
     +                     uvwd_diff)
C-------------------------------------------------------------------
C     Same as SRDVEL, but with finite core radius
C-------------------------------------------------------------------
      REAL uvws(3), uvwd(3, 3)
      REAL uvws_diff(3), uvwd_diff(3, 3)
C
      REAL r1(3), r2(3)
      REAL r1_diff(3), r2_diff(3)
      REAL rxr(3)
      REAL rxr_diff(3)
      REAL rcsq
      REAL rcsq_diff
      REAL r1sq
      REAL r1sq_diff
      REAL r2sq
      REAL r2sq_diff
      REAL r1sqeps
      REAL r1sqeps_diff
      REAL r2sqeps
      REAL r2sqeps_diff
      REAL r1eps
      REAL r1eps_diff
      INTRINSIC SQRT
      REAL r2eps
      REAL r2eps_diff
      REAL rdr
      REAL rdr_diff
      REAL xdx
      REAL xdx_diff
      REAL all
      REAL all_diff
      REAL den
      REAL den_diff
      REAL ai1
      REAL ai1_diff
      REAL ai2
      REAL ai2_diff
      INTEGER k
      REAL rr1
      REAL rr1_diff
      REAL rr2
      REAL rr2_diff
      REAL rrt
      REAL rrt_diff
      REAL aj1
      REAL aj1_diff
      REAL aj2
      REAL aj2_diff
      INTEGER j
      INTEGER l
      REAL temp
      REAL temp_diff
      INTEGER ii1
      REAL temp0
      REAL temp_diff0
      REAL temp_diff1
      REAL y1
      REAL y1_diff
      REAL y2
      REAL y2_diff
      REAL rcore
      REAL rcore_diff
      REAL x
      REAL x_diff
      REAL y
      REAL y_diff
      REAL z
      REAL z_diff
      REAL z1
      REAL z1_diff
      REAL z2
      REAL z2_diff
      REAL x1
      REAL x1_diff
      REAL x2
      REAL x2_diff
      REAL beta
      REAL beta_diff
      REAL pi4inv
C
      DATA pi4inv /0.079577472/
C
      r1(1) = (x1-x)/beta
      r1(2) = y1 - y
      r1(3) = z1 - z
C
      r2(1) = (x2-x)/beta
      r2(2) = y2 - y
      r2(3) = z2 - z
C
      rcsq = rcore**2
C
      r1sq = r1(1)**2 + r1(2)**2 + r1(3)**2
      r2sq = r2(1)**2 + r2(2)**2 + r2(3)**2
C
      r1sqeps = r1sq + rcsq
      r2sqeps = r2sq + rcsq
C
      r1eps = SQRT(r1sqeps)
      r2eps = SQRT(r2sqeps)
C
      rdr = r1(1)*r2(1) + r1(2)*r2(2) + r1(3)*r2(3)
      rxr(1) = r1(2)*r2(3) - r1(3)*r2(2)
      rxr(2) = r1(3)*r2(1) - r1(1)*r2(3)
      rxr(3) = r1(1)*r2(2) - r1(2)*r2(1)
C
      xdx = rxr(1)**2 + rxr(2)**2 + rxr(3)**2
C
      all = r1sq + r2sq - 2.0*rdr
C
      den = rcsq*all + xdx
C
      ai1 = ((rdr+rcsq)/r1eps-r2eps)/den
      ai2 = ((rdr+rcsq)/r2eps-r1eps)/den
C
C---- set velocity components for unit source and doublet
      DO k=1,3
        CALL PUSHREAL8(uvws(k))
        uvws(k) = r1(k)*ai1 + r2(k)*ai2
C
        CALL PUSHREAL8(rr1)
        rr1 = (r1(k)+r2(k))/r1eps - r1(k)*(rdr+rcsq)/(r1eps*r1eps*r1eps)
     +    - r2(k)/r2eps
C
        CALL PUSHREAL8(rr2)
        rr2 = (r1(k)+r2(k))/r2eps - r2(k)*(rdr+rcsq)/(r2eps*r2eps*r2eps)
     +    - r1(k)/r1eps
C
        rrt = 2.0*r1(k)*(r2sq-rdr) + 2.0*r2(k)*(r1sq-rdr)
C
        aj1 = (rr1-ai1*rrt)/den
C
        aj2 = (rr2-ai2*rrt)/den
C
        DO j=1,3
          CALL PUSHREAL8(uvwd(k, j))
          uvwd(k, j) = -(aj1*r1(j)) - aj2*r2(j)
        ENDDO
C
        CALL PUSHREAL8(uvwd(k, k))
        uvwd(k, k) = uvwd(k, k) - ai1 - ai2
      ENDDO
      DO l=3,1,-1
        uvwd_diff(3, l) = pi4inv*uvwd_diff(3, l)
        uvwd_diff(2, l) = pi4inv*uvwd_diff(2, l)
        temp_diff1 = pi4inv*uvwd_diff(1, l)/beta
        uvwd_diff(1, l) = temp_diff1
        beta_diff = beta_diff - uvwd(1, l)*temp_diff1/beta
      ENDDO
      uvws_diff(3) = pi4inv*uvws_diff(3)
      uvws_diff(2) = pi4inv*uvws_diff(2)
      temp_diff1 = pi4inv*uvws_diff(1)/beta
      uvws_diff(1) = temp_diff1
      beta_diff = beta_diff - uvws(1)*temp_diff1/beta
      r1eps_diff = 0.D0
      r2sq_diff = 0.D0
      ai1_diff = 0.D0
      ai2_diff = 0.D0
      den_diff = 0.D0
      r1sq_diff = 0.D0
      rdr_diff = 0.D0
      DO ii1=1,3
        r1_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        r2_diff(ii1) = 0.D0
      ENDDO
      rcsq_diff = 0.D0
      r2eps_diff = 0.D0
      DO k=3,1,-1
        CALL POPREAL8(uvwd(k, k))
        ai1_diff = ai1_diff - uvwd_diff(k, k)
        ai2_diff = ai2_diff - uvwd_diff(k, k)
        rrt = 2.0*r1(k)*(r2sq-rdr) + 2.0*r2(k)*(r1sq-rdr)
        aj1 = (rr1-ai1*rrt)/den
        aj2 = (rr2-ai2*rrt)/den
        aj1_diff = 0.D0
        aj2_diff = 0.D0
        DO j=3,1,-1
          CALL POPREAL8(uvwd(k, j))
          aj1_diff = aj1_diff - r1(j)*uvwd_diff(k, j)
          r1_diff(j) = r1_diff(j) - aj1*uvwd_diff(k, j)
          aj2_diff = aj2_diff - r2(j)*uvwd_diff(k, j)
          r2_diff(j) = r2_diff(j) - aj2*uvwd_diff(k, j)
          uvwd_diff(k, j) = 0.D0
        ENDDO
        temp_diff1 = aj2_diff/den
        rr2_diff = temp_diff1
        ai2_diff = ai2_diff + r2(k)*uvws_diff(k) - rrt*temp_diff1
        rrt_diff = -(ai2*temp_diff1)
        den_diff = den_diff - (rr2-ai2*rrt)*temp_diff1/den
        temp_diff1 = aj1_diff/den
        rr1_diff = temp_diff1
        ai1_diff = ai1_diff + r1(k)*uvws_diff(k) - rrt*temp_diff1
        rrt_diff = rrt_diff - ai1*temp_diff1
        den_diff = den_diff - (rr1-ai1*rrt)*temp_diff1/den
        temp_diff1 = r1(k)*2.0*rrt_diff
        temp_diff0 = r2(k)*2.0*rrt_diff
        r1sq_diff = r1sq_diff + temp_diff0
        rdr_diff = rdr_diff - temp_diff0 - temp_diff1
        r2sq_diff = r2sq_diff + temp_diff1
        CALL POPREAL8(rr2)
        temp0 = r2eps*r2eps*r2eps
        temp_diff1 = rr2_diff/r2eps
        r1_diff(k) = r1_diff(k) + (r2sq-rdr)*2.0*rrt_diff + temp_diff1 -
     +    rr2_diff/r1eps
        temp_diff = -(rr2_diff/temp0)
        r2eps_diff = r2eps_diff + r2(k)*rr1_diff/r2eps**2 - 3*r2eps**2*
     +    r2(k)*(rdr+rcsq)*temp_diff/temp0 - (r1(k)+r2(k))*temp_diff1/
     +    r2eps
        CALL POPREAL8(rr1)
        temp = r1eps*r1eps*r1eps
        temp_diff0 = rr1_diff/r1eps
        r2_diff(k) = r2_diff(k) + (r1sq-rdr)*2.0*rrt_diff + (rdr+rcsq)*
     +    temp_diff + temp_diff1 + temp_diff0 - rr1_diff/r2eps + ai2*
     +    uvws_diff(k)
        temp_diff1 = -(rr1_diff/temp)
        r1eps_diff = r1eps_diff + r1(k)*rr2_diff/r1eps**2 - 3*r1eps**2*
     +    r1(k)*(rdr+rcsq)*temp_diff1/temp - (r1(k)+r2(k))*temp_diff0/
     +    r1eps
        rdr_diff = rdr_diff + r2(k)*temp_diff + r1(k)*temp_diff1
        rcsq_diff = rcsq_diff + r2(k)*temp_diff + r1(k)*temp_diff1
        r1_diff(k) = r1_diff(k) + (rdr+rcsq)*temp_diff1 + temp_diff0 + 
     +    ai1*uvws_diff(k)
        CALL POPREAL8(uvws(k))
        uvws_diff(k) = 0.D0
      ENDDO
      temp = (rdr+rcsq)/r2eps
      temp_diff0 = ai2_diff/den
      temp_diff = temp_diff0/r2eps
      r1eps_diff = r1eps_diff - temp_diff0
      rdr_diff = rdr_diff + temp_diff
      rcsq_diff = rcsq_diff + temp_diff
      r2eps_diff = r2eps_diff - temp*temp_diff
      temp0 = (rdr+rcsq)/r1eps
      temp_diff = ai1_diff/den
      den_diff = den_diff - (temp-r1eps)*temp_diff0/den - (temp0-r2eps)*
     +  temp_diff/den
      temp_diff0 = temp_diff/r1eps
      r2eps_diff = r2eps_diff - temp_diff
      r1eps_diff = r1eps_diff - temp0*temp_diff0
      all_diff = rcsq*den_diff
      rdr_diff = rdr_diff + temp_diff0 - 2.0*all_diff
      xdx_diff = den_diff
      DO ii1=1,3
        rxr_diff(ii1) = 0.D0
      ENDDO
      rxr_diff(1) = rxr_diff(1) + 2*rxr(1)*xdx_diff
      rxr_diff(2) = rxr_diff(2) + 2*rxr(2)*xdx_diff
      rxr_diff(3) = rxr_diff(3) + 2*rxr(3)*xdx_diff
      IF (r2sqeps .EQ. 0.D0) THEN
        r2sqeps_diff = 0.D0
      ELSE
        r2sqeps_diff = r2eps_diff/(2.0*SQRT(r2sqeps))
      END IF
      r2sq_diff = r2sq_diff + all_diff + r2sqeps_diff
      r2_diff(2) = r2_diff(2) + r1(1)*rxr_diff(3) + r1(2)*rdr_diff - r1(
     +  3)*rxr_diff(1) + 2*r2(2)*r2sq_diff
      r2_diff(1) = r2_diff(1) + r1(3)*rxr_diff(2) - r1(2)*rxr_diff(3) + 
     +  r1(1)*rdr_diff + 2*r2(1)*r2sq_diff
      r2_diff(3) = r2_diff(3) + r1(2)*rxr_diff(1) - r1(1)*rxr_diff(2) + 
     +  r1(3)*rdr_diff + 2*r2(3)*r2sq_diff
      IF (r1sqeps .EQ. 0.D0) THEN
        r1sqeps_diff = 0.D0
      ELSE
        r1sqeps_diff = r1eps_diff/(2.0*SQRT(r1sqeps))
      END IF
      rcsq_diff = rcsq_diff + temp_diff0 + all*den_diff + r2sqeps_diff +
     +  r1sqeps_diff
      r1sq_diff = r1sq_diff + all_diff + r1sqeps_diff
      r1_diff(1) = r1_diff(1) + r2(2)*rxr_diff(3) + r2(1)*rdr_diff - r2(
     +  3)*rxr_diff(2) + 2*r1(1)*r1sq_diff
      r1_diff(2) = r1_diff(2) + r2(3)*rxr_diff(1) - r2(1)*rxr_diff(3) + 
     +  r2(2)*rdr_diff + 2*r1(2)*r1sq_diff
      rxr_diff(3) = 0.D0
      r1_diff(3) = r1_diff(3) + r2(1)*rxr_diff(2) + r2(3)*rdr_diff - r2(
     +  2)*rxr_diff(1) + 2*r1(3)*r1sq_diff
      rxr_diff(2) = 0.D0
      rcore_diff = rcore_diff + 2*rcore*rcsq_diff
      z2_diff = z2_diff + r2_diff(3)
      z_diff = z_diff - r2_diff(3) - r1_diff(3)
      r2_diff(3) = 0.D0
      y2_diff = y2_diff + r2_diff(2)
      y_diff = y_diff - r2_diff(2) - r1_diff(2)
      r2_diff(2) = 0.D0
      temp_diff = r2_diff(1)/beta
      x2_diff = x2_diff + temp_diff
      x_diff = x_diff - temp_diff
      beta_diff = beta_diff - (x2-x)*temp_diff/beta
      z1_diff = z1_diff + r1_diff(3)
      r1_diff(3) = 0.D0
      y1_diff = y1_diff + r1_diff(2)
      r1_diff(2) = 0.D0
      temp_diff = r1_diff(1)/beta
      x1_diff = x1_diff + temp_diff
      x_diff = x_diff - temp_diff
      beta_diff = beta_diff - (x1-x)*temp_diff/beta
      END
C SRDVELC
C
C
C
C
C

