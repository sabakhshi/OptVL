C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.16 (develop) - 22 Aug 2023 15:51
C
C  Differentiation of build_aic in reverse (adjoint) mode (with options i4 dr8 r8):
C   gradient     of useful results: aicn ysym zsym mach rv1 rv2
C                rc chordv enc
C   with respect to varying inputs: ysym zsym mach rv1 rv2 rc chordv
C                enc
C SETUP
C
C
      SUBROUTINE BUILD_AIC_B()
      use avl_heap_inc
      use avl_heap_diff_inc
C
      INCLUDE 'AVL.INC'
      INCLUDE 'AVL_ad_seeds.inc'
      REAL betm
      REAL betm_diff
      INTRINSIC SQRT
      INTEGER j
      INTEGER i
      INTEGER n
      INTEGER j1
      INTEGER jn
      INTEGER i1
      INTEGER iv
      INTEGER jv
      INTEGER ii3
      INTEGER ii2
      INTEGER ii1
C
      amach = mach
      betm = SQRT(1.0 - amach**2)
c           CALL VVOR(betm, iysym, ysym, izsym, zsym, vrcorec, vrcorew, nvor,  assume analysis run before
c          +          rv1, rv2, lvcomp, chordv, nvor, rc, lvcomp, .false.,   
c          +          wc_gam, nvor)  
C$BWD-OF II-LOOP 
      DO n=1,nsurf
        IF (.NOT.lfwake(n)) THEN
C
C------- go over TE control points on this surface
          j1 = jfrst(n)
          jn = jfrst(n) + nj(n) - 1
C$BWD-OF II-LOOP 
          DO j=j1,jn
            i1 = ijfrst(j)
            iv = ijfrst(j) + nvstrp(j) - 1
C$BWD-OF II-LOOP 
            DO jv=i1,iv
              aicn_diff(iv, jv) = 0.D0
            ENDDO
C$BWD-OF II-LOOP 
            DO jv=1,nvor
              aicn_diff(iv, jv) = 0.D0
            ENDDO
          ENDDO
        END IF
      ENDDO
      DO ii1=1,nvor
        DO ii2=1,nvor
          DO ii3=1,3
            wc_gam_diff(ii3, ii2, ii1) = 0.D0
          ENDDO
        ENDDO
      ENDDO
C$BWD-OF II-LOOP 
      DO j=1,nvor
C$BWD-OF II-LOOP 
        DO i=1,nvor
          wc_gam_diff(1, i, j) = wc_gam_diff(1, i, j) + enc(1, i)*
     +      aicn_diff(i, j)
          enc_diff(1, i) = enc_diff(1, i) + wc_gam(1, i, j)*aicn_diff(i
     +      , j)
          wc_gam_diff(2, i, j) = wc_gam_diff(2, i, j) + enc(2, i)*
     +      aicn_diff(i, j)
          enc_diff(2, i) = enc_diff(2, i) + wc_gam(2, i, j)*aicn_diff(i
     +      , j)
          wc_gam_diff(3, i, j) = wc_gam_diff(3, i, j) + enc(3, i)*
     +      aicn_diff(i, j)
          enc_diff(3, i) = enc_diff(3, i) + wc_gam(3, i, j)*aicn_diff(i
     +      , j)
          aicn_diff(i, j) = 0.D0
        ENDDO
      ENDDO
      betm_diff = 0.D0
      CALL VVOR_B(betm, betm_diff, iysym, ysym, ysym_diff, izsym, zsym, 
     +            zsym_diff, vrcorec, vrcorew, nvor, rv1, rv1_diff, rv2
     +            , rv2_diff, lvcomp, chordv, chordv_diff, nvor, rc, 
     +            rc_diff, lvcomp, .false., wc_gam, wc_gam_diff, nvor)
      IF (1.0 - amach**2 .EQ. 0.D0) THEN
        amach_diff = 0.D0
      ELSE
        amach_diff = -(2*amach*betm_diff/(2.0*SQRT(1.0-amach**2)))
      END IF
      mach_diff = mach_diff + amach_diff
      END

C  Differentiation of velsum in reverse (adjoint) mode (with options i4 dr8 r8):
C   gradient     of useful results: vinf wrot gam gam_u gam_d vv
C                vv_u vv_d wv wv_u wv_d
C   with respect to varying inputs: wv_gam vinf wrot gam gam_u
C                gam_d vv vv_u vv_d wv wv_u wv_d
C   RW status of diff variables: wv_gam:out vinf:incr wrot:incr
C                gam:incr gam_u:incr gam_d:incr vv:in-out vv_u:in-out
C                vv_d:in-out wv:in-out wv_u:in-out wv_d:in-out
C GAMSUM
C
C
      SUBROUTINE VELSUM_B()
      use avl_heap_inc
      use avl_heap_diff_inc
C
      INCLUDE 'AVL.INC'
      INCLUDE 'AVL_ad_seeds.inc'
      INTEGER i
      INTEGER k
      INTEGER j
      INTEGER n
      INTEGER ii2
      INTEGER ii1
      INTEGER ii3
      DO ii1=1,nvor
        DO ii2=1,nvor
          DO ii3=1,3
            wv_gam_diff(ii3, ii2, ii1) = 0.D0
          ENDDO
        ENDDO
      ENDDO
      DO ii1=1,nvor
        DO ii2=1,3
          wvsrd_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO i=nvor,1,-1
        DO k=3,1,-1
          DO n=ndmax,1,-1
            vv_d_diff(k, i, n) = vv_d_diff(k, i, n) + wv_d_diff(k, i, n)
            wv_d_diff(k, i, n) = 0.D0
          ENDDO
          DO n=numax,1,-1
            vv_u_diff(k, i, n) = vv_u_diff(k, i, n) + wv_u_diff(k, i, n)
            wv_u_diff(k, i, n) = 0.D0
          ENDDO
          vv_diff(k, i) = vv_diff(k, i) + wv_diff(k, i)
          wvsrd_diff(k, i) = wvsrd_diff(k, i) + wv_diff(k, i)
          wv_diff(k, i) = 0.D0
          vinf_diff(1) = vinf_diff(1) + wvsrd_u(k, i, 1)*wvsrd_diff(k, i
     +      )
          vinf_diff(2) = vinf_diff(2) + wvsrd_u(k, i, 2)*wvsrd_diff(k, i
     +      )
          vinf_diff(3) = vinf_diff(3) + wvsrd_u(k, i, 3)*wvsrd_diff(k, i
     +      )
          wrot_diff(1) = wrot_diff(1) + wvsrd_u(k, i, 4)*wvsrd_diff(k, i
     +      )
          wrot_diff(2) = wrot_diff(2) + wvsrd_u(k, i, 5)*wvsrd_diff(k, i
     +      )
          wrot_diff(3) = wrot_diff(3) + wvsrd_u(k, i, 6)*wvsrd_diff(k, i
     +      )
          wvsrd_diff(k, i) = 0.D0
          DO n=ncontrol,1,-1
            DO j=nvor,1,-1
              wv_gam_diff(k, i, j) = wv_gam_diff(k, i, j) + gam_d(j, n)*
     +          vv_d_diff(k, i, n)
              gam_d_diff(j, n) = gam_d_diff(j, n) + wv_gam(k, i, j)*
     +          vv_d_diff(k, i, n)
            ENDDO
            vv_d_diff(k, i, n) = 0.D0
          ENDDO
          DO n=numax,1,-1
            DO j=nvor,1,-1
              wv_gam_diff(k, i, j) = wv_gam_diff(k, i, j) + gam_u(j, n)*
     +          vv_u_diff(k, i, n)
              gam_u_diff(j, n) = gam_u_diff(j, n) + wv_gam(k, i, j)*
     +          vv_u_diff(k, i, n)
            ENDDO
            vv_u_diff(k, i, n) = 0.D0
          ENDDO
          DO j=nvor,1,-1
            wv_gam_diff(k, i, j) = wv_gam_diff(k, i, j) + gam(j)*vv_diff
     +        (k, i)
            gam_diff(j) = gam_diff(j) + wv_gam(k, i, j)*vv_diff(k, i)
          ENDDO
          vv_diff(k, i) = 0.D0
        ENDDO
      ENDDO
      END

C  Differentiation of set_par_and_cons in reverse (adjoint) mode (with options i4 dr8 r8):
C   gradient     of useful results: alfa beta wrot delcon xyzref
C                mach cdref
C   with respect to varying inputs: alfa beta wrot parval conval
C                delcon xyzref
C VELSUM
      SUBROUTINE SET_PAR_AND_CONS_B(niter, ir)
      INCLUDE 'AVL.INC'
      INCLUDE 'AVL_ad_seeds.inc'
C mach setting is done in here. Should it be?
      INTEGER niter, ir
      INTEGER n
      INTEGER iv
      INTEGER ic
C Additionally set the reference point to be at the cg
C
C
C
      INTEGER ii2
      INTEGER ii1
      INTEGER*4 branch
      IF (niter .GT. 0) THEN
C----- might as well directly set operating variables if they are known
        IF (icon(ivalfa, ir) .EQ. icalfa) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        IF (icon(ivbeta, ir) .EQ. icbeta) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        IF (icon(ivrotx, ir) .EQ. icrotx) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        IF (icon(ivroty, ir) .EQ. icroty) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        IF (icon(ivrotz, ir) .EQ. icrotz) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        DO ii1=1,nrmax
          DO ii2=1,icmax
            conval_diff(ii2, ii1) = 0.D0
          ENDDO
        ENDDO
C$BWD-OF II-LOOP 
        DO n=1,ndmax
          iv = ivtot + n
          ic = ictot + n
          IF (icon(iv, ir) .EQ. ic) THEN
            conval_diff(ic, ir) = conval_diff(ic, ir) + delcon_diff(n)
            delcon_diff(n) = 0.D0
          END IF
        ENDDO
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          conval_diff(icrotz, ir) = conval_diff(icrotz, ir) + 2.*
     +      wrot_diff(3)/bref
          wrot_diff(3) = 0.D0
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          conval_diff(icroty, ir) = conval_diff(icroty, ir) + 2.*
     +      wrot_diff(2)/cref
          wrot_diff(2) = 0.D0
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          conval_diff(icrotx, ir) = conval_diff(icrotx, ir) + 2.*
     +      wrot_diff(1)/bref
          wrot_diff(1) = 0.D0
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          conval_diff(icbeta, ir) = conval_diff(icbeta, ir) + dtr*
     +      beta_diff
          beta_diff = 0.D0
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          conval_diff(icalfa, ir) = conval_diff(icalfa, ir) + dtr*
     +      alfa_diff
          alfa_diff = 0.D0
        END IF
      ELSE
        DO ii1=1,nrmax
          DO ii2=1,icmax
            conval_diff(ii2, ii1) = 0.D0
          ENDDO
        ENDDO
      END IF
      DO ii1=1,nrmax
        DO ii2=1,ipmax
          parval_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      parval_diff(ipcd0, ir) = parval_diff(ipcd0, ir) + cdref_diff
      parval_diff(ipzcg, ir) = parval_diff(ipzcg, ir) + xyzref_diff(3)
      xyzref_diff(3) = 0.D0
      parval_diff(ipycg, ir) = parval_diff(ipycg, ir) + xyzref_diff(2)
      xyzref_diff(2) = 0.D0
      parval_diff(ipxcg, ir) = parval_diff(ipxcg, ir) + xyzref_diff(1)
      xyzref_diff(1) = 0.D0
      CALL SET_PARAMS_B(ir)
      END

C  Differentiation of set_vel_rhs in reverse (adjoint) mode (with options i4 dr8 r8):
C   gradient     of useful results: vinf wrot delcon xyzref rc
C                enc_d wcsrd_u rhs
C   with respect to varying inputs: vinf wrot delcon xyzref rc
C                enc enc_d wcsrd_u
      SUBROUTINE SET_VEL_RHS_B()
      INCLUDE 'AVL.INC'
      INCLUDE 'AVL_ad_seeds.inc'
      REAL rrot(3), vunit(3), vunit_w_term(3), wunit(3)
      REAL rrot_diff(3), vunit_diff(3), vunit_w_term_diff(3), wunit_diff
     +     (3)
      INTEGER i
      REAL DOT
      INTEGER n
      REAL result1
      REAL result1_diff
      INTEGER*4 branch
      enc_diff = 0.D0
      vunit_diff = 0.D0
      wunit_diff = 0.D0
      vunit_w_term_diff = 0.D0
      rrot_diff = 0.D0
C$BWD-OF II-LOOP 
      DO i=1,nvor
        IF (lvnc(i)) THEN
          vunit(1) = 0.
          vunit(2) = 0.
          vunit(3) = 0.
          wunit(1) = 0.
          wunit(2) = 0.
          wunit(3) = 0.
CTODO-opt: only do this if boddies
          IF (lvalbe(i)) THEN
            vunit(1) = vinf(1)
            vunit(2) = vinf(2)
            vunit(3) = vinf(3)
            wunit(1) = wrot(1)
            wunit(2) = wrot(2)
            wunit(3) = wrot(3)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          vunit(1) = vunit(1) + wcsrd_u(1, i, 1)*vinf(1) + wcsrd_u(1, i
     +      , 2)*vinf(2) + wcsrd_u(1, i, 3)*vinf(3)
          vunit(2) = vunit(2) + wcsrd_u(2, i, 1)*vinf(1) + wcsrd_u(2, i
     +      , 2)*vinf(2) + wcsrd_u(2, i, 3)*vinf(3)
          vunit(3) = vunit(3) + wcsrd_u(3, i, 1)*vinf(1) + wcsrd_u(3, i
     +      , 2)*vinf(2) + wcsrd_u(3, i, 3)*vinf(3)
          rrot(1) = rc(1, i) - xyzref(1)
          rrot(2) = rc(2, i) - xyzref(2)
          rrot(3) = rc(3, i) - xyzref(3)
          CALL CROSS(rrot, wunit, vunit_w_term)
C
          vunit_w_term(1) = vunit_w_term(1) + wcsrd_u(1, i, 1)*wrot(1) +
     +      wcsrd_u(1, i, 2)*wrot(2) + wcsrd_u(1, i, 3)*wrot(3)
          vunit_w_term(2) = vunit_w_term(2) + wcsrd_u(2, i, 1)*wrot(1) +
     +      wcsrd_u(2, i, 2)*wrot(2) + wcsrd_u(2, i, 3)*wrot(3)
          vunit_w_term(3) = vunit_w_term(3) + wcsrd_u(3, i, 1)*wrot(1) +
     +      wcsrd_u(3, i, 2)*wrot(2) + wcsrd_u(3, i, 3)*wrot(3)
C
          vunit = vunit + vunit_w_term
C Add contribution from control surfaces
C$BWD-OF II-LOOP 
          DO n=1,ncontrol
            result1 = DOT(enc_d(1, i, n), vunit)
            result1_diff = -(delcon(n)*rhs_diff(i))
            delcon_diff(n) = delcon_diff(n) - result1*rhs_diff(i)
            CALL DOT_B(enc_d(1, i, n), enc_d_diff(1, i, n), vunit, 
     +                 vunit_diff, result1_diff)
          ENDDO
          result1_diff = -rhs_diff(i)
          rhs_diff(i) = 0.D0
          CALL DOT_B(enc(1, i), enc_diff(1, i), vunit, vunit_diff, 
     +               result1_diff)
          vunit_w_term_diff = vunit_w_term_diff + vunit_diff
          wcsrd_u_diff(3, i, 1) = wcsrd_u_diff(3, i, 1) + wrot(1)*
     +      vunit_w_term_diff(3) + vinf(1)*vunit_diff(3)
          wrot_diff(1) = wrot_diff(1) + wcsrd_u(3, i, 1)*
     +      vunit_w_term_diff(3) + wcsrd_u(2, i, 1)*vunit_w_term_diff(2)
     +      + wcsrd_u(1, i, 1)*vunit_w_term_diff(1)
          wcsrd_u_diff(3, i, 2) = wcsrd_u_diff(3, i, 2) + wrot(2)*
     +      vunit_w_term_diff(3) + vinf(2)*vunit_diff(3)
          wrot_diff(2) = wrot_diff(2) + wcsrd_u(3, i, 2)*
     +      vunit_w_term_diff(3) + wcsrd_u(2, i, 2)*vunit_w_term_diff(2)
     +      + wcsrd_u(1, i, 2)*vunit_w_term_diff(1)
          wcsrd_u_diff(3, i, 3) = wcsrd_u_diff(3, i, 3) + wrot(3)*
     +      vunit_w_term_diff(3) + vinf(3)*vunit_diff(3)
          wrot_diff(3) = wrot_diff(3) + wcsrd_u(3, i, 3)*
     +      vunit_w_term_diff(3) + wcsrd_u(2, i, 3)*vunit_w_term_diff(2)
     +      + wcsrd_u(1, i, 3)*vunit_w_term_diff(1)
          wcsrd_u_diff(2, i, 1) = wcsrd_u_diff(2, i, 1) + wrot(1)*
     +      vunit_w_term_diff(2) + vinf(1)*vunit_diff(2)
          wcsrd_u_diff(2, i, 2) = wcsrd_u_diff(2, i, 2) + wrot(2)*
     +      vunit_w_term_diff(2) + vinf(2)*vunit_diff(2)
          wcsrd_u_diff(2, i, 3) = wcsrd_u_diff(2, i, 3) + wrot(3)*
     +      vunit_w_term_diff(2) + vinf(3)*vunit_diff(2)
          wcsrd_u_diff(1, i, 1) = wcsrd_u_diff(1, i, 1) + wrot(1)*
     +      vunit_w_term_diff(1) + vinf(1)*vunit_diff(1)
          wcsrd_u_diff(1, i, 2) = wcsrd_u_diff(1, i, 2) + wrot(2)*
     +      vunit_w_term_diff(1) + vinf(2)*vunit_diff(1)
          wcsrd_u_diff(1, i, 3) = wcsrd_u_diff(1, i, 3) + wrot(3)*
     +      vunit_w_term_diff(1) + vinf(3)*vunit_diff(1)
          CALL CROSS_B(rrot, rrot_diff, wunit, wunit_diff, vunit_w_term
     +                 , vunit_w_term_diff)
          rc_diff(3, i) = rc_diff(3, i) + rrot_diff(3)
          xyzref_diff(3) = xyzref_diff(3) - rrot_diff(3)
          rrot_diff(3) = 0.D0
          rc_diff(2, i) = rc_diff(2, i) + rrot_diff(2)
          xyzref_diff(2) = xyzref_diff(2) - rrot_diff(2)
          rrot_diff(2) = 0.D0
          rc_diff(1, i) = rc_diff(1, i) + rrot_diff(1)
          xyzref_diff(1) = xyzref_diff(1) - rrot_diff(1)
          rrot_diff(1) = 0.D0
          vinf_diff(1) = vinf_diff(1) + wcsrd_u(3, i, 1)*vunit_diff(3) +
     +      wcsrd_u(2, i, 1)*vunit_diff(2) + wcsrd_u(1, i, 1)*vunit_diff
     +      (1)
          vinf_diff(2) = vinf_diff(2) + wcsrd_u(3, i, 2)*vunit_diff(3) +
     +      wcsrd_u(2, i, 2)*vunit_diff(2) + wcsrd_u(1, i, 2)*vunit_diff
     +      (1)
          vinf_diff(3) = vinf_diff(3) + wcsrd_u(3, i, 3)*vunit_diff(3) +
     +      wcsrd_u(2, i, 3)*vunit_diff(2) + wcsrd_u(1, i, 3)*vunit_diff
     +      (1)
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            wrot_diff(3) = wrot_diff(3) + wunit_diff(3)
            wunit_diff(3) = 0.D0
            wrot_diff(2) = wrot_diff(2) + wunit_diff(2)
            wunit_diff(2) = 0.D0
            wrot_diff(1) = wrot_diff(1) + wunit_diff(1)
            wunit_diff(1) = 0.D0
            vinf_diff(3) = vinf_diff(3) + vunit_diff(3)
            vunit_diff(3) = 0.D0
            vinf_diff(2) = vinf_diff(2) + vunit_diff(2)
            vunit_diff(2) = 0.D0
            vinf_diff(1) = vinf_diff(1) + vunit_diff(1)
            vunit_diff(1) = 0.D0
          END IF
          wunit_diff(3) = 0.D0
          wunit_diff(2) = 0.D0
          wunit_diff(1) = 0.D0
          vunit_diff(3) = 0.D0
          vunit_diff(2) = 0.D0
          vunit_diff(1) = 0.D0
        ELSE
          rhs_diff(i) = 0.D0
        END IF
      ENDDO
      END

C  Differentiation of set_vel_rhs_u in reverse (adjoint) mode (with options i4 dr8 r8):
C   gradient     of useful results: delcon xyzref rc enc enc_d
C                wcsrd_u rhs_u
C   with respect to varying inputs: delcon xyzref rc enc enc_d
C                wcsrd_u rhs_u
Cset_vel_rhs
C
      SUBROUTINE SET_VEL_RHS_U_B(iu)
      INCLUDE 'AVL.INC'
      INCLUDE 'AVL_ad_seeds.inc'
      REAL rrot(3), vunit(3), vunit_w_term(3), wunit(3)
      REAL rrot_diff(3), vunit_diff(3), vunit_w_term_diff(3), wunit_diff
     +     (3)
      INTEGER i
      REAL DOT
      INTEGER n
      REAL result1
      REAL result1_diff
      INTEGER*4 branch
      INTEGER iu
      vunit_diff = 0.D0
      vunit_w_term_diff = 0.D0
      rrot_diff = 0.D0
C$BWD-OF II-LOOP 
      DO i=1,nvor
        IF (lvnc(i)) THEN
          vunit(1) = 0.
          vunit(2) = 0.
          vunit(3) = 0.
          wunit(1) = 0.
          wunit(2) = 0.
          wunit(3) = 0.
          IF (lvalbe(i)) THEN
            IF (iu .LE. 3) THEN
              CALL PUSHCONTROL2B(0)
              vunit(iu) = vunit(iu) + 1.0
            ELSE IF (iu .LE. 6) THEN
              CALL PUSHCONTROL2B(1)
              wunit(iu-3) = wunit(iu-3) + 1.0
            ELSE
              CALL PUSHCONTROL2B(1)
            END IF
          ELSE
            CALL PUSHCONTROL2B(2)
          END IF
C--------- always add on indirect freestream influence via BODY sources and doublets
          vunit(1) = vunit(1) + wcsrd_u(1, i, iu)
          vunit(2) = vunit(2) + wcsrd_u(2, i, iu)
          vunit(3) = vunit(3) + wcsrd_u(3, i, iu)
C
          rrot(1) = rc(1, i) - xyzref(1)
          rrot(2) = rc(2, i) - xyzref(2)
          rrot(3) = rc(3, i) - xyzref(3)
          CALL CROSS(rrot, wunit, vunit_w_term)
          vunit = vunit + vunit_w_term
C Add contribution from control surfaces
C$BWD-OF II-LOOP 
          DO n=1,ncontrol
            result1 = DOT(enc_d(1, i, n), vunit)
            result1_diff = -(delcon(n)*rhs_u_diff(i, iu))
            delcon_diff(n) = delcon_diff(n) - result1*rhs_u_diff(i, iu)
            CALL DOT_B(enc_d(1, i, n), enc_d_diff(1, i, n), vunit, 
     +                 vunit_diff, result1_diff)
          ENDDO
          result1_diff = -rhs_u_diff(i, iu)
          rhs_u_diff(i, iu) = 0.D0
          CALL DOT_B(enc(1, i), enc_diff(1, i), vunit, vunit_diff, 
     +               result1_diff)
          vunit_w_term_diff = vunit_w_term_diff + vunit_diff
          wunit_diff = 0.D0
          CALL CROSS_B(rrot, rrot_diff, wunit, wunit_diff, vunit_w_term
     +                 , vunit_w_term_diff)
          rc_diff(3, i) = rc_diff(3, i) + rrot_diff(3)
          xyzref_diff(3) = xyzref_diff(3) - rrot_diff(3)
          rrot_diff(3) = 0.D0
          rc_diff(2, i) = rc_diff(2, i) + rrot_diff(2)
          xyzref_diff(2) = xyzref_diff(2) - rrot_diff(2)
          rrot_diff(2) = 0.D0
          rc_diff(1, i) = rc_diff(1, i) + rrot_diff(1)
          xyzref_diff(1) = xyzref_diff(1) - rrot_diff(1)
          rrot_diff(1) = 0.D0
          wcsrd_u_diff(3, i, iu) = wcsrd_u_diff(3, i, iu) + vunit_diff(3
     +      )
          wcsrd_u_diff(2, i, iu) = wcsrd_u_diff(2, i, iu) + vunit_diff(2
     +      )
          wcsrd_u_diff(1, i, iu) = wcsrd_u_diff(1, i, iu) + vunit_diff(1
     +      )
          CALL POPCONTROL2B(branch)
          vunit_diff(3) = 0.D0
          vunit_diff(2) = 0.D0
          vunit_diff(1) = 0.D0
        ELSE
          rhs_u_diff(i, iu) = 0.D0
        END IF
      ENDDO
      END

C  Differentiation of set_gam_d_rhs in reverse (adjoint) mode (with options i4 dr8 r8):
C   gradient     of useful results: vinf wrot xyzref rc wcsrd_u
C                rhs_vec enc_q
C   with respect to varying inputs: vinf wrot xyzref rc wcsrd_u
C                rhs_vec enc_q
Cset_vel_rhs_u
      SUBROUTINE SET_GAM_D_RHS_B(iq, enc_q, enc_q_diff, rhs_vec, 
     +                           rhs_vec_diff)
      INCLUDE 'AVL.INC'
      INCLUDE 'AVL_ad_seeds.inc'
      REAL enc_q(3, nvmax, *), rhs_vec(nvmax)
      REAL enc_q_diff(3, nvmax, *), rhs_vec_diff(nvmax)
      REAL rrot(3), vrot(3), vq(3)
      REAL rrot_diff(3), vrot_diff(3), vq_diff(3)
      INTEGER i
      INTEGER k
      REAL DOT
      REAL result1
      REAL result1_diff
      INTEGER*4 branch
      INTEGER ii1
      INTEGER iq
      DO ii1=1,3
        vrot_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        vq_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        rrot_diff(ii1) = 0.D0
      ENDDO
C$BWD-OF II-LOOP 
      DO i=1,nvor
        IF (lvnc(i)) THEN
          IF (lvalbe(i)) THEN
            rrot(1) = rc(1, i) - xyzref(1)
            rrot(2) = rc(2, i) - xyzref(2)
            rrot(3) = rc(3, i) - xyzref(3)
            CALL CROSS(rrot, wrot, vrot)
C$FWD-OF II-LOOP 
            DO k=1,3
              vq(k) = vinf(k) + vrot(k)
            ENDDO
            CALL PUSHCONTROL1B(0)
          ELSE
            vq(1) = 0.
            vq(2) = 0.
            vq(3) = 0.
            CALL PUSHCONTROL1B(1)
          END IF
C$FWD-OF II-LOOP 
          DO k=1,3
            vq(k) = vq(k) + wcsrd_u(k, i, 1)*vinf(1) + wcsrd_u(k, i, 2)*
     +        vinf(2) + wcsrd_u(k, i, 3)*vinf(3) + wcsrd_u(k, i, 4)*wrot
     +        (1) + wcsrd_u(k, i, 5)*wrot(2) + wcsrd_u(k, i, 6)*wrot(3)
          ENDDO
          result1_diff = -rhs_vec_diff(i)
          rhs_vec_diff(i) = 0.D0
          CALL DOT_B(enc_q(1, i, iq), enc_q_diff(1, i, iq), vq, vq_diff
     +               , result1_diff)
C$BWD-OF II-LOOP 
          DO k=1,3
            wcsrd_u_diff(k, i, 1) = wcsrd_u_diff(k, i, 1) + vinf(1)*
     +        vq_diff(k)
            vinf_diff(1) = vinf_diff(1) + wcsrd_u(k, i, 1)*vq_diff(k)
            wcsrd_u_diff(k, i, 2) = wcsrd_u_diff(k, i, 2) + vinf(2)*
     +        vq_diff(k)
            vinf_diff(2) = vinf_diff(2) + wcsrd_u(k, i, 2)*vq_diff(k)
            wcsrd_u_diff(k, i, 3) = wcsrd_u_diff(k, i, 3) + vinf(3)*
     +        vq_diff(k)
            vinf_diff(3) = vinf_diff(3) + wcsrd_u(k, i, 3)*vq_diff(k)
            wcsrd_u_diff(k, i, 4) = wcsrd_u_diff(k, i, 4) + wrot(1)*
     +        vq_diff(k)
            wrot_diff(1) = wrot_diff(1) + wcsrd_u(k, i, 4)*vq_diff(k)
            wcsrd_u_diff(k, i, 5) = wcsrd_u_diff(k, i, 5) + wrot(2)*
     +        vq_diff(k)
            wrot_diff(2) = wrot_diff(2) + wcsrd_u(k, i, 5)*vq_diff(k)
            wcsrd_u_diff(k, i, 6) = wcsrd_u_diff(k, i, 6) + wrot(3)*
     +        vq_diff(k)
            wrot_diff(3) = wrot_diff(3) + wcsrd_u(k, i, 6)*vq_diff(k)
          ENDDO
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
C$BWD-OF II-LOOP 
            DO k=1,3
              vinf_diff(k) = vinf_diff(k) + vq_diff(k)
              vrot_diff(k) = vrot_diff(k) + vq_diff(k)
              vq_diff(k) = 0.D0
            ENDDO
            CALL CROSS_B(rrot, rrot_diff, wrot, wrot_diff, vrot, 
     +                   vrot_diff)
            rc_diff(3, i) = rc_diff(3, i) + rrot_diff(3)
            xyzref_diff(3) = xyzref_diff(3) - rrot_diff(3)
            rrot_diff(3) = 0.D0
            rc_diff(2, i) = rc_diff(2, i) + rrot_diff(2)
            xyzref_diff(2) = xyzref_diff(2) - rrot_diff(2)
            rrot_diff(2) = 0.D0
            rc_diff(1, i) = rc_diff(1, i) + rrot_diff(1)
            xyzref_diff(1) = xyzref_diff(1) - rrot_diff(1)
            rrot_diff(1) = 0.D0
          ELSE
            vq_diff(3) = 0.D0
            vq_diff(2) = 0.D0
            vq_diff(1) = 0.D0
          END IF
        ELSE
          rhs_vec_diff(i) = 0.D0
        END IF
      ENDDO
      END

C  Differentiation of mat_prod in reverse (adjoint) mode (with options i4 dr8 r8):
C   gradient     of useful results: vec out_vec mat
C   with respect to varying inputs: vec mat
C set_gam_d_rhs
C
      SUBROUTINE MAT_PROD_B(mat, mat_diff, vec, vec_diff, n, out_vec, 
     +                      out_vec_diff)
      INCLUDE 'AVL.INC'
      INCLUDE 'AVL_ad_seeds.inc'
      INTEGER n
      REAL mat(n, n), vec(nvmax), out_vec(nvmax)
      REAL mat_diff(n, n), vec_diff(nvmax), out_vec_diff(nvmax)
      INTEGER j
      INTEGER i
C$BWD-OF II-LOOP 
      DO j=1,n
C$BWD-OF II-LOOP 
        DO i=1,n
          mat_diff(i, j) = mat_diff(i, j) + vec(j)*out_vec_diff(i)
          vec_diff(j) = vec_diff(j) + mat(i, j)*out_vec_diff(i)
        ENDDO
      ENDDO
      END
Cmat_prod

