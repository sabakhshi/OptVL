C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.16 (develop) - 22 Aug 2023 15:51
C
C  Differentiation of update_surfaces in forward (tangent) mode (with options i4 dr8 r8):
C   variations   of useful results: rle chord rle1 chord1 rle2
C                chord2 wstrip ess ensy ensz xsref ysref zsref
C                rv1 rv2 rv rc rs dxv chordv enc env enc_d
C   with respect to varying inputs: xyzscal xyztran addinc xyzles
C                chords aincs xasec sasec claf mshblk
C   RW status of diff variables: xyzscal:in xyztran:in addinc:in
C                xyzles:in chords:in aincs:in xasec:in sasec:in
C                claf:in mshblk:in rle:out chord:out rle1:out chord1:out
C                rle2:out chord2:out wstrip:out ess:out ensy:out
C                ensz:out xsref:out ysref:out zsref:out rv1:out
C                rv2:out rv:out rc:out rs:out dxv:out chordv:out
C                enc:out env:out enc_d:out
      SUBROUTINE UPDATE_SURFACES_D()
      use avl_heap_inc
      use avl_heap_diff_inc
      INCLUDE 'AVL.INC'
      INCLUDE 'AVL_ad_seeds.inc'
      INTEGER ii
      INTEGER isurf
      EXTERNAL AVLHEAP_CLEAN
      EXTERNAL AVLHEAP_DIFF_CLEAN
      EXTERNAL AVLHEAP_INIT
      EXTERNAL AVLHEAP_DIFF_INIT
      INTEGER ii3
      INTEGER ii2
      INTEGER ii1
      nstrip = 0
      nvor = 0
      isurf = 1
      nsurfdupl = 0
      DO ii=1,nsurf
        IF (ldupl(ii)) nsurfdupl = nsurfdupl + 1
      ENDDO
      DO ii1=1,nvor
        DO ii2=1,3
          rv1msh_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,nvor
        DO ii2=1,3
          rv2msh_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,nvor
        DO ii2=1,3
          rvmsh_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,nvor
        DO ii2=1,3
          rcmsh_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,NSTRIP
        DO ii2=1,3
          rle_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,NSTRIP
        chord_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,NSTRIP
        DO ii2=1,3
          rle1_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,NSTRIP
        chord1_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,NSTRIP
        DO ii2=1,3
          rle2_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,NSTRIP
        chord2_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,NSTRIP
        wstrip_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,NSTRIP
        ainc_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,ngmax
        DO ii2=1,NSTRIP
          ainc_g_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,nvor
        DO ii2=1,3
          rv1_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,nvor
        DO ii2=1,3
          rv2_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,nvor
        DO ii2=1,3
          rv_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,nvor
        DO ii2=1,3
          rc_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,nvor
        DO ii2=1,3
          rs_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,nvor
        dxv_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nvor
        chordv_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nvor
        slopev_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nvor
        slopec_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,ndmax
        DO ii2=1,nvor
          dcontrol_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,ndmax
        DO ii2=1,NSTRIP
          DO ii3=1,3
            vhinge_diff(ii3, ii2, ii1) = 0.D0
          ENDDO
        ENDDO
      ENDDO
C     the iterations of this loop are not independent because we count
C     up the size information as we make each surface
      DO ii=1,nsurf-nsurfdupl
        IF (lverbose) WRITE(*, *) 'Updating surface ', isurf
        IF (lsurfmsh(isurf)) THEN
          CALL MAKESURF_MESH_D(isurf)
        ELSE
          CALL MAKESURF_D(isurf)
        END IF
        IF (ldupl(isurf)) THEN
          IF (lverbose) WRITE(*, *) ' reduplicating ', isurf
          CALL SDUPL_D(isurf, ydupl(isurf), 'ydup')
          isurf = isurf + 1
        END IF
        isurf = isurf + 1
      ENDDO
      CALL ENCALC_D()
C     reset all the flags related to the analysis pipline      
      laic = .false.
      lsrd = .false.
      lvel = .false.
      lsol = .false.
      lsen = .false.
C
      IF (naic .NE. nvor) THEN
        CALL AVLHEAP_CLEAN()
        CALL AVLHEAP_DIFF_CLEAN()
        CALL AVLHEAP_INIT(nvor)
        CALL AVLHEAP_DIFF_INIT(nvor)
      END IF
      END

C  Differentiation of makesurf in forward (tangent) mode (with options i4 dr8 r8):
C   variations   of useful results: rle chord rle1 chord1 rle2
C                chord2 wstrip ainc ainc_g rv1 rv2 rv rc rs dxv
C                chordv slopev slopec dcontrol vhinge
C   with respect to varying inputs: xyzscal xyztran addinc xyzles
C                chords aincs xasec sasec claf rle chord rle1 chord1
C                rle2 chord2 wstrip ainc ainc_g rv1 rv2 rv rc rs
C                dxv chordv slopev slopec dcontrol vhinge
C***********************************************************************
C    Module:  amake.f
C 
C    Copyright (C) 2002 Mark Drela, Harold Youngren
C 
C    This program is free software; you can redistribute it and/or modify
C    it under the terms of the GNU General Public License as published by
C    the Free Software Foundation; either version 2 of the License, or
C    (at your option) any later version.
C
C    This program is distributed in the hope that it will be useful,
C    but WITHOUT ANY WARRANTY; without even the implied warranty of
C    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
C    GNU General Public License for more details.
C
C    You should have received a copy of the GNU General Public License
C    along with this program; if not, write to the Free Software
C    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
C***********************************************************************
C
      SUBROUTINE MAKESURF_D(isurf)
      INCLUDE 'AVL.INC'
      INCLUDE 'AVL_ad_seeds.inc'
C
C
      REAL xyzlel(3), xyzler(3)
      REAL xyzlel_diff(3), xyzler_diff(3)
      INTEGER kcmax
      INTEGER ksmax
      PARAMETER (kcmax=50, ksmax=500)
      REAL xpt0(kcmax), xcp0(kcmax), xvr0(kcmax), xsr0(kcmax), xpt1(
     +     kcmax), xcp1(kcmax), xvr1(kcmax), xsr1(kcmax), xpt2(kcmax), 
     +     xcp2(kcmax), xvr2(kcmax), xsr2(kcmax)
      REAL xpt(kcmax), xcp(kcmax), xvr(kcmax), xsr(kcmax), ypt(ksmax), 
     +     ycp(ksmax)
      REAL xcp_diff(kcmax), xvr_diff(kcmax), ypt_diff(ksmax), ycp_diff(
     +     ksmax)
      REAL yzlen(ksmax)
      REAL yzlen_diff(ksmax)
      INTEGER iptloc(ksmax)
      INTEGER kpmax
      PARAMETER (kpmax=2*kcmax+2*ksmax)
      REAL fspace(kpmax)
C
      REAL chsinl_g(ngmax), chcosl_g(ngmax), chsinr_g(ngmax), chcosr_g(
     +     ngmax)
      REAL chsinl_g_diff(ngmax), chcosl_g_diff(ngmax), chsinr_g_diff(
     +     ngmax), chcosr_g_diff(ngmax)
      INTEGER isconl(ndmax), isconr(ndmax)
      REAL xled(ndmax), xted(ndmax), gainda(ndmax)
      REAL xled_diff(ndmax), xted_diff(ndmax), gainda_diff(ndmax)
      INTEGER idx_vor, idx_strip
      INTEGER isec
      REAL dy
      REAL dy_diff
      REAL dz
      REAL dz_diff
      INTRINSIC SQRT
      REAL dyzlen
      REAL dyzlen_diff
      INTEGER nvint
      INTEGER nspace
      INTEGER n
      INTEGER ivs
      INTEGER npt
      REAL yptloc
      INTEGER ipt
      REAL yptdel
      INTRINSIC ABS
      INTEGER ipt1
      INTEGER ipt2
      REAL ypt1
      REAL ypt1_diff
      REAL yscale
      REAL yscale_diff
      INTEGER ii
      REAL width
      REAL width_diff
      REAL chordl
      REAL chordl_diff
      REAL chordr
      REAL chordr_diff
      REAL clafl
      REAL clafl_diff
      REAL clafr
      REAL clafr_diff
      REAL aincl
      REAL aincl_diff
      REAL aincr
      REAL aincr_diff
      REAL chsinl
      REAL chsinl_diff
      INTRINSIC SIN
      REAL chsinr
      REAL chsinr_diff
      REAL chcosl
      REAL chcosl_diff
      INTRINSIC COS
      REAL chcosr
      REAL chcosr_diff
      INTEGER iscon
      INTEGER isdes
      INTEGER iptl
      INTEGER iptr
      INTEGER nspan
      INTEGER ispan
      REAL f1
      REAL f1_diff
      REAL f2
      REAL f2_diff
      REAL fc
      REAL fc_diff
      REAL chsin
      REAL chsin_diff
      REAL chcos
      REAL chcos_diff
      INTRINSIC ATAN2
      REAL chsin_g
      REAL chsin_g_diff
      REAL chcos_g
      REAL chcos_g_diff
      INTEGER icl
      INTEGER icr
      REAL xhd
      REAL xhd_diff
      REAL vhx
      REAL vhx_diff
      REAL vhy
      REAL vhy_diff
      REAL vhz
      REAL vhz_diff
      REAL vsq
      REAL vsq_diff
      REAL vmod
      REAL vmod_diff
      INTEGER l
      INTEGER nsl
      INTEGER nsr
      REAL chordc
      REAL chordc_diff
      REAL clafc
      REAL clafc_diff
      INTEGER ivc
      REAL slopel
      REAL slopel_diff
      REAL dsdx
      REAL sloper
      REAL sloper_diff
      REAL dxoc
      REAL fracle
      REAL fracle_diff
      REAL fracte
      REAL fracte_diff
      INTRINSIC MAX
      INTRINSIC MIN
      REAL zl_l
      REAL zu_l
      REAL zl_r
      REAL zu_r
      REAL zl
      REAL zu
      REAL sum
      REAL wtot
      INTEGER jj
      INTEGER j
      REAL astrp
      INTEGER nst
      EXTERNAL STRIP
      REAL y1
      REAL y1_diff
      REAL y2
      REAL y2_diff
      REAL abs0
      REAL abs0_diff
      REAL(kind=avl_real) abs1
      REAL(kind=avl_real) abs1_diff
      REAL(kind=avl_real) abs2
      REAL(kind=avl_real) abs2_diff
      REAL arg1
      REAL arg1_diff
      REAL result1
      REAL result1_diff
      REAL temp
      INTEGER ii1
      REAL temp0
      INTEGER isurf
C
C
      IF (nsec(isurf) .LT. 2) THEN
        WRITE(*, *) '*** Need at least 2 sections per surface.'
        STOP
      ELSE
C
C
        IF (nvc(isurf) .GT. kcmax) THEN
          WRITE(*, *) '* MAKESURF: Array overflow.  Increase KCMAX to', 
     +          nvc(isurf)
          nvc(isurf) = kcmax
        END IF
C
        IF (nvs(isurf) .GT. ksmax) THEN
          WRITE(*, *) '* MAKESURF: Array overflow.  Increase KSMAX to', 
     +          nvs(isurf)
          nvs(isurf) = ksmax
        END IF
C
C--- Image flag set to indicate section definition direction
C    IMAGS= 1  defines edge 1 located at surface root edge 
C    IMAGS=-1  defines edge 2 located at surface root edge (reflected surfaces)
        imags(isurf) = 1
C write(*,*) 'IFRST(ISURF)', IFRST(ISURF)
C IFRST(ISURF) = NVOR   + 1 
C write(*,*) 'IFRST(ISURF) 2', IFRST(ISURF)
C JFRST(ISURF) = NSTRIP + 1
        IF (isurf .EQ. 1) THEN
          ifrst(isurf) = 1
        ELSE
          ifrst(isurf) = ifrst(isurf-1) + nk(isurf-1)*nj(isurf-1)
        END IF
        IF (isurf .EQ. 1) THEN
          jfrst(isurf) = 1
        ELSE
          jfrst(isurf) = jfrst(isurf-1) + nj(isurf-1)
        END IF
        nk(isurf) = nvc(isurf)
        idx_strip = jfrst(isurf)
C
C-----------------------------------------------------------------
C---- Arc length positions of sections in wing trace in y-z plane
        yzlen(1) = 0.
        DO ii1=1,ksmax
          yzlen_diff(ii1) = 0.D0
        ENDDO
        DO isec=2,nsec(isurf)
          dy_diff = xyzles_diff(2, isec, isurf) - xyzles_diff(2, isec-1
     +      , isurf)
          dy = xyzles(2, isec, isurf) - xyzles(2, isec-1, isurf)
          dz_diff = xyzles_diff(3, isec, isurf) - xyzles_diff(3, isec-1
     +      , isurf)
          dz = xyzles(3, isec, isurf) - xyzles(3, isec-1, isurf)
          arg1_diff = 2*dy*dy_diff + 2*dz*dz_diff
          arg1 = dy*dy + dz*dz
          temp = SQRT(arg1)
          IF (arg1 .EQ. 0.D0) THEN
            result1_diff = 0.D0
          ELSE
            result1_diff = arg1_diff/(2.0*temp)
          END IF
          result1 = temp
          yzlen_diff(isec) = yzlen_diff(isec-1) + result1_diff
          yzlen(isec) = yzlen(isec-1) + result1
C we can not rely on the original condition becuase NVS(ISURF) is filled 
C and we may want to rebuild the surface later
        ENDDO
C
        IF (nvs(isurf) .EQ. 0 .OR. (lsurfspacing(isurf) .EQV. .false.)) 
     +  THEN
C----- set spanwise spacing using spacing parameters for each section interval
          DO isec=1,nsec(isurf)-1
            nvs(isurf) = nvs(isurf) + nspans(isec, isurf)
          ENDDO
          IF (nvs(isurf) .GT. ksmax) THEN
            WRITE(*, *) '*** MAKESURF: Array overflow. Increase', 
     +            'KSMAX to', nvs(isurf)
            STOP
          ELSE
C
            nvs(isurf) = 0
            DO ii1=1,ksmax
              ypt_diff(ii1) = 0.D0
            ENDDO
            ypt_diff(1) = yzlen_diff(1)
            ypt(1) = yzlen(1)
            iptloc(1) = 1
            DO ii1=1,ksmax
              ycp_diff(ii1) = 0.D0
            ENDDO
C
            DO isec=1,nsec(isurf)-1
              dyzlen_diff = yzlen_diff(isec+1) - yzlen_diff(isec)
              dyzlen = yzlen(isec+1) - yzlen(isec)
C
              nvint = nspans(isec, isurf)
C
C------- set spanwise spacing array
              nspace = 2*nvint + 1
              IF (nspace .GT. kpmax) THEN
                GOTO 100
              ELSE
                CALL SPACER(nspace, sspaces(isec, isurf), fspace)
C
                DO n=1,nvint
                  ivs = nvs(isurf) + n
                  ycp_diff(ivs) = ypt_diff(nvs(isurf)+1) + fspace(2*n)*
     +              dyzlen_diff
                  ycp(ivs) = ypt(nvs(isurf)+1) + dyzlen*fspace(2*n)
                  ypt_diff(ivs+1) = ypt_diff(nvs(isurf)+1) + fspace(2*n+
     +              1)*dyzlen_diff
                  ypt(ivs+1) = ypt(nvs(isurf)+1) + dyzlen*fspace(2*n+1)
                ENDDO
                iptloc(isec+1) = nvs(isurf) + nvint + 1
C
                nvs(isurf) = nvs(isurf) + nvint
              END IF
            ENDDO
            GOTO 130
 100        WRITE(*, *) 
     +            '*** MAKESURF: Array overflow. Increase KPMAX to', 
     +            nspace
            STOP
          END IF
        ELSE
C
C
C----- Otherwise, set spanwise spacing using the SURFACE spanwise
C      parameters NVS, SSPACE
C
C      This spanwise spacing is modified (fudged) to align vortex edges
C      with SECTIONs as defined.  This allows CONTROLs to be defined
C      without bridging vortex strips
C
          nspace = 2*nvs(isurf) + 1
          IF (nspace .GT. kpmax) THEN
            WRITE(*, *) 
     +            '*** MAKESURF: Array overflow. Increase KPMAX to', 
     +            nspace
            STOP
          ELSE
            CALL SPACER(nspace, sspace(isurf), fspace)
C
            DO ii1=1,ksmax
              ypt_diff(ii1) = 0.D0
            ENDDO
            ypt_diff(1) = yzlen_diff(1)
            ypt(1) = yzlen(1)
            DO ii1=1,ksmax
              ycp_diff(ii1) = 0.D0
            ENDDO
            DO ivs=1,nvs(isurf)
              ycp_diff(ivs) = yzlen_diff(1) + fspace(2*ivs)*(yzlen_diff(
     +          nsec(isurf))-yzlen_diff(1))
              ycp(ivs) = yzlen(1) + (yzlen(nsec(isurf))-yzlen(1))*fspace
     +          (2*ivs)
              ypt_diff(ivs+1) = yzlen_diff(1) + fspace(2*ivs+1)*(
     +          yzlen_diff(nsec(isurf))-yzlen_diff(1))
              ypt(ivs+1) = yzlen(1) + (yzlen(nsec(isurf))-yzlen(1))*
     +          fspace(2*ivs+1)
            ENDDO
C
            npt = nvs(isurf) + 1
C
C----- find node nearest each section
            DO isec=2,nsec(isurf)-1
              yptloc = 1.0e9
              iptloc(isec) = 1
              DO ipt=1,npt
                IF (yzlen(isec) - ypt(ipt) .GE. 0.) THEN
                  yptdel = yzlen(isec) - ypt(ipt)
                ELSE
                  yptdel = -(yzlen(isec)-ypt(ipt))
                END IF
                IF (yptdel .LT. yptloc) THEN
                  yptloc = yptdel
                  iptloc(isec) = ipt
                END IF
              ENDDO
            ENDDO
            iptloc(1) = 1
            iptloc(nsec(isurf)) = npt
C
C----- fudge spacing array to make nodes match up exactly with interior sections
C Throws an error in the case where the same node is the closest node 
C to two consecutive sections
            DO isec=2,nsec(isurf)-1
              ipt1 = iptloc(isec-1)
              ipt2 = iptloc(isec)
              IF (ipt1 .EQ. ipt2) THEN
                GOTO 110
              ELSE
C
C----- fudge spacing to this section so that nodes match up exactly with section
                ypt1_diff = ypt_diff(ipt1)
                ypt1 = ypt(ipt1)
                temp = (yzlen(isec)-yzlen(isec-1))/(ypt(ipt2)-ypt(ipt1))
                yscale_diff = (yzlen_diff(isec)-yzlen_diff(isec-1)-temp*
     +            (ypt_diff(ipt2)-ypt_diff(ipt1)))/(ypt(ipt2)-ypt(ipt1))
                yscale = temp
                DO ipt=ipt1,ipt2-1
                  ypt_diff(ipt) = yzlen_diff(isec-1) + (ypt(ipt)-ypt1)*
     +              yscale_diff + yscale*(ypt_diff(ipt)-ypt1_diff)
                  ypt(ipt) = yzlen(isec-1) + yscale*(ypt(ipt)-ypt1)
                ENDDO
                DO ivs=ipt1,ipt2-1
                  ycp_diff(ivs) = yzlen_diff(isec-1) + (ycp(ivs)-ypt1)*
     +              yscale_diff + yscale*(ycp_diff(ivs)-ypt1_diff)
                  ycp(ivs) = yzlen(isec-1) + yscale*(ycp(ivs)-ypt1)
                ENDDO
C
C----- check for unique spacing node for next section, if not we need more nodes
                ipt1 = iptloc(isec)
                ipt2 = iptloc(isec+1)
                IF (ipt1 .EQ. ipt2) THEN
                  GOTO 120
                ELSE
C
C----- fudge spacing to this section so that nodes match up exactly with section
                  ypt1_diff = ypt_diff(ipt1)
                  ypt1 = ypt(ipt1)
                  temp = (ypt(ipt2)-yzlen(isec))/(ypt(ipt2)-ypt(ipt1))
                  yscale_diff = (ypt_diff(ipt2)-yzlen_diff(isec)-temp*(
     +              ypt_diff(ipt2)-ypt_diff(ipt1)))/(ypt(ipt2)-ypt(ipt1)
     +              )
                  yscale = temp
                  DO ipt=ipt1,ipt2-1
                    ypt_diff(ipt) = yzlen_diff(isec) + (ypt(ipt)-ypt1)*
     +                yscale_diff + yscale*(ypt_diff(ipt)-ypt1_diff)
                    ypt(ipt) = yzlen(isec) + yscale*(ypt(ipt)-ypt1)
                  ENDDO
                  DO ivs=ipt1,ipt2-1
                    ycp_diff(ivs) = yzlen_diff(isec) + (ycp(ivs)-ypt1)*
     +                yscale_diff + yscale*(ycp_diff(ivs)-ypt1_diff)
                    ycp(ivs) = yzlen(isec) + yscale*(ycp(ivs)-ypt1)
                  ENDDO
                END IF
              END IF
            ENDDO
            GOTO 130
 110        CALL STRIP(stitle(isurf), nst)
            WRITE(*, 7000) isec, stitle(isurf)(1:nst)
            STOP
 120        CALL STRIP(stitle(isurf), nst)
            WRITE(*, 7000) isec, stitle(isurf)(1:nst)
            STOP
          END IF
        END IF
C
Cc#ifdef USE_CPOML
C...  store section counters
 130    IF (isurf .EQ. 1) THEN
          icntfrst(isurf) = 1
        ELSE
          icntfrst(isurf) = icntfrst(isurf-1) + ncntsec(isurf-1)
        END IF
        ncntsec(isurf) = nsec(isurf)
        DO isec=1,nsec(isurf)
          ii = icntfrst(isurf) + (isec-1)
          icntsec(ii) = iptloc(isec)
        ENDDO
Cc#endif
C
C
C====================================================
C---- define strips between input sections
C
        nj(isurf) = 0
C
        IF (ncontrol .GT. ndmax) THEN
          WRITE(*, *) 
     +          '*** Too many control variables.  Increase NDMAX to', 
     +          ncontrol
          STOP
        ELSE IF (ndesign .GT. ngmax) THEN
C
          WRITE(*, *) 
     +          '*** Too many design variables.  Increase NGMAX to', 
     +          ndesign
          STOP
        ELSE
          DO ii1=1,3
            xyzler_diff(ii1) = 0.D0
          ENDDO
          DO ii1=1,kcmax
            xcp_diff(ii1) = 0.D0
          ENDDO
          DO ii1=1,ngmax
            chcosl_g_diff(ii1) = 0.D0
          ENDDO
          DO ii1=1,ngmax
            chsinr_g_diff(ii1) = 0.D0
          ENDDO
          DO ii1=1,ndmax
            xted_diff(ii1) = 0.D0
          ENDDO
          DO ii1=1,ndmax
            xled_diff(ii1) = 0.D0
          ENDDO
          DO ii1=1,ngmax
            chsinl_g_diff(ii1) = 0.D0
          ENDDO
          DO ii1=1,ndmax
            gainda_diff(ii1) = 0.D0
          ENDDO
          DO ii1=1,ngmax
            chcosr_g_diff(ii1) = 0.D0
          ENDDO
          DO ii1=1,3
            xyzlel_diff(ii1) = 0.D0
          ENDDO
C
C---- go over section intervals
          DO isec=1,nsec(isurf)-1
            xyzlel_diff(1) = xyzles(1, isec, isurf)*xyzscal_diff(1, 
     +        isurf) + xyzscal(1, isurf)*xyzles_diff(1, isec, isurf) + 
     +        xyztran_diff(1, isurf)
            xyzlel(1) = xyzscal(1, isurf)*xyzles(1, isec, isurf) + 
     +        xyztran(1, isurf)
            xyzlel_diff(2) = xyzles(2, isec, isurf)*xyzscal_diff(2, 
     +        isurf) + xyzscal(2, isurf)*xyzles_diff(2, isec, isurf) + 
     +        xyztran_diff(2, isurf)
            xyzlel(2) = xyzscal(2, isurf)*xyzles(2, isec, isurf) + 
     +        xyztran(2, isurf)
            xyzlel_diff(3) = xyzles(3, isec, isurf)*xyzscal_diff(3, 
     +        isurf) + xyzscal(3, isurf)*xyzles_diff(3, isec, isurf) + 
     +        xyztran_diff(3, isurf)
            xyzlel(3) = xyzscal(3, isurf)*xyzles(3, isec, isurf) + 
     +        xyztran(3, isurf)
            xyzler_diff(1) = xyzles(1, isec+1, isurf)*xyzscal_diff(1, 
     +        isurf) + xyzscal(1, isurf)*xyzles_diff(1, isec+1, isurf) +
     +        xyztran_diff(1, isurf)
            xyzler(1) = xyzscal(1, isurf)*xyzles(1, isec+1, isurf) + 
     +        xyztran(1, isurf)
            xyzler_diff(2) = xyzles(2, isec+1, isurf)*xyzscal_diff(2, 
     +        isurf) + xyzscal(2, isurf)*xyzles_diff(2, isec+1, isurf) +
     +        xyztran_diff(2, isurf)
            xyzler(2) = xyzscal(2, isurf)*xyzles(2, isec+1, isurf) + 
     +        xyztran(2, isurf)
            xyzler_diff(3) = xyzles(3, isec+1, isurf)*xyzscal_diff(3, 
     +        isurf) + xyzscal(3, isurf)*xyzles_diff(3, isec+1, isurf) +
     +        xyztran_diff(3, isurf)
            xyzler(3) = xyzscal(3, isurf)*xyzles(3, isec+1, isurf) + 
     +        xyztran(3, isurf)
C
            arg1_diff = 2*(xyzler(2)-xyzlel(2))*(xyzler_diff(2)-
     +        xyzlel_diff(2)) + 2*(xyzler(3)-xyzlel(3))*(xyzler_diff(3)-
     +        xyzlel_diff(3))
            arg1 = (xyzler(2)-xyzlel(2))**2 + (xyzler(3)-xyzlel(3))**2
            temp = SQRT(arg1)
            IF (arg1 .EQ. 0.D0) THEN
              width_diff = 0.D0
            ELSE
              width_diff = arg1_diff/(2.0*temp)
            END IF
            width = temp
C
            chordl_diff = chords(isec, isurf)*xyzscal_diff(1, isurf) + 
     +        xyzscal(1, isurf)*chords_diff(isec, isurf)
            chordl = xyzscal(1, isurf)*chords(isec, isurf)
            chordr_diff = chords(isec+1, isurf)*xyzscal_diff(1, isurf) +
     +        xyzscal(1, isurf)*chords_diff(isec+1, isurf)
            chordr = xyzscal(1, isurf)*chords(isec+1, isurf)
C
            clafl_diff = claf_diff(isec, isurf)
            clafl = claf(isec, isurf)
            clafr_diff = claf_diff(isec+1, isurf)
            clafr = claf(isec+1, isurf)
C
C------ removed CLAF influence on zero-lift angle  (MD  21 Mar 08)
            aincl_diff = dtr*aincs_diff(isec, isurf) + dtr*addinc_diff(
     +        isurf)
            aincl = aincs(isec, isurf)*dtr + addinc(isurf)*dtr
            aincr_diff = dtr*aincs_diff(isec+1, isurf) + dtr*addinc_diff
     +        (isurf)
            aincr = aincs(isec+1, isurf)*dtr + addinc(isurf)*dtr
Cc      AINCL = AINCS(ISEC)   + ADDINC(ISURF) - 4.0*DTR*(CLAFL-1.0)
Cc      AINCR = AINCS(ISEC+1) + ADDINC(ISURF) - 4.0*DTR*(CLAFR-1.0)
C
            temp = SIN(aincl)
            chsinl_diff = temp*chordl_diff + chordl*COS(aincl)*
     +        aincl_diff
            chsinl = chordl*temp
            temp = SIN(aincr)
            chsinr_diff = temp*chordr_diff + chordr*COS(aincr)*
     +        aincr_diff
            chsinr = chordr*temp
            temp = COS(aincl)
            chcosl_diff = temp*chordl_diff - chordl*SIN(aincl)*
     +        aincl_diff
            chcosl = chordl*temp
            temp = COS(aincr)
            chcosr_diff = temp*chordr_diff - chordr*SIN(aincr)*
     +        aincr_diff
            chcosr = chordr*temp
C
C------ set control-declaration lines for each control variable
            DO n=1,ncontrol
              isconl(n) = 0
              isconr(n) = 0
              DO iscon=1,nscon(isec, isurf)
                IF (icontd(iscon, isec, isurf) .EQ. n) isconl(n) = iscon
              ENDDO
              DO iscon=1,nscon(isec+1, isurf)
                IF (icontd(iscon, isec+1, isurf) .EQ. n) isconr(n) = 
     +              iscon
              ENDDO
            ENDDO
C
C------ set design-variable sensitivities of CHSIN and CHCOS
            DO n=1,ndesign
              chsinl_g_diff(n) = 0.D0
              chsinl_g(n) = 0.
              chsinr_g_diff(n) = 0.D0
              chsinr_g(n) = 0.
              chcosl_g_diff(n) = 0.D0
              chcosl_g(n) = 0.
              chcosr_g_diff(n) = 0.D0
              chcosr_g(n) = 0.
C
              DO isdes=1,nsdes(isec, isurf)
                IF (idestd(isdes, isec, isurf) .EQ. n) THEN
                  chsinl_g_diff(n) = gaing(isdes, isec, isurf)*dtr*
     +              chcosl_diff
                  chsinl_g(n) = chcosl*gaing(isdes, isec, isurf)*dtr
                  chcosl_g_diff(n) = -(gaing(isdes, isec, isurf)*dtr*
     +              chsinl_diff)
                  chcosl_g(n) = -(chsinl*gaing(isdes, isec, isurf)*dtr)
                END IF
              ENDDO
C
              DO isdes=1,nsdes(isec+1, isurf)
                IF (idestd(isdes, isec+1, isurf) .EQ. n) THEN
                  chsinr_g_diff(n) = gaing(isdes, isec+1, isurf)*dtr*
     +              chcosr_diff
                  chsinr_g(n) = chcosr*gaing(isdes, isec+1, isurf)*dtr
                  chcosr_g_diff(n) = -(gaing(isdes, isec+1, isurf)*dtr*
     +              chsinr_diff)
                  chcosr_g(n) = -(chsinr*gaing(isdes, isec+1, isurf)*dtr
     +              )
                END IF
              ENDDO
            ENDDO
C
C
C------ go over chord strips
            iptl = iptloc(isec)
            iptr = iptloc(isec+1)
            nspan = iptr - iptl
            nj(isurf) = nj(isurf) + nspan
C
            DO ispan=1,nspan
C-------- define left and right edges of vortex strip
C-          note that incidence angle is set by ATAN of chord projections,
C-          not by linear interpolation of AINC
              ipt1 = iptl + ispan - 1
              ipt2 = iptl + ispan
              ivs = iptl + ispan - 1
              temp = (ypt(ipt1)-ypt(iptl))/(ypt(iptr)-ypt(iptl))
              f1_diff = (ypt_diff(ipt1)-ypt_diff(iptl)-temp*(ypt_diff(
     +          iptr)-ypt_diff(iptl)))/(ypt(iptr)-ypt(iptl))
              f1 = temp
              temp = (ypt(ipt2)-ypt(iptl))/(ypt(iptr)-ypt(iptl))
              f2_diff = (ypt_diff(ipt2)-ypt_diff(iptl)-temp*(ypt_diff(
     +          iptr)-ypt_diff(iptl)))/(ypt(iptr)-ypt(iptl))
              f2 = temp
C     NSTRIP = NSTRIP + 1
C     NJ(ISURF) = NJ(ISURF) + 1
              temp = (ycp(ivs)-ypt(iptl))/(ypt(iptr)-ypt(iptl))
              fc_diff = (ycp_diff(ivs)-ypt_diff(iptl)-temp*(ypt_diff(
     +          iptr)-ypt_diff(iptl)))/(ypt(iptr)-ypt(iptl))
              fc = temp
C
C-------- store strip in global data arrays
C
              rle1_diff(1, idx_strip) = (1.0-f1)*xyzlel_diff(1) - (
     +          xyzlel(1)-xyzler(1))*f1_diff + f1*xyzler_diff(1)
              rle1(1, idx_strip) = (1.0-f1)*xyzlel(1) + f1*xyzler(1)
              rle1_diff(2, idx_strip) = (1.0-f1)*xyzlel_diff(2) - (
     +          xyzlel(2)-xyzler(2))*f1_diff + f1*xyzler_diff(2)
              rle1(2, idx_strip) = (1.0-f1)*xyzlel(2) + f1*xyzler(2)
              rle1_diff(3, idx_strip) = (1.0-f1)*xyzlel_diff(3) - (
     +          xyzlel(3)-xyzler(3))*f1_diff + f1*xyzler_diff(3)
              rle1(3, idx_strip) = (1.0-f1)*xyzlel(3) + f1*xyzler(3)
              chord1_diff(idx_strip) = (1.0-f1)*chordl_diff - (chordl-
     +          chordr)*f1_diff + f1*chordr_diff
              chord1(idx_strip) = (1.0-f1)*chordl + f1*chordr
C
              rle2_diff(1, idx_strip) = (1.0-f2)*xyzlel_diff(1) - (
     +          xyzlel(1)-xyzler(1))*f2_diff + f2*xyzler_diff(1)
              rle2(1, idx_strip) = (1.0-f2)*xyzlel(1) + f2*xyzler(1)
              rle2_diff(2, idx_strip) = (1.0-f2)*xyzlel_diff(2) - (
     +          xyzlel(2)-xyzler(2))*f2_diff + f2*xyzler_diff(2)
              rle2(2, idx_strip) = (1.0-f2)*xyzlel(2) + f2*xyzler(2)
              rle2_diff(3, idx_strip) = (1.0-f2)*xyzlel_diff(3) - (
     +          xyzlel(3)-xyzler(3))*f2_diff + f2*xyzler_diff(3)
              rle2(3, idx_strip) = (1.0-f2)*xyzlel(3) + f2*xyzler(3)
              chord2_diff(idx_strip) = (1.0-f2)*chordl_diff - (chordl-
     +          chordr)*f2_diff + f2*chordr_diff
              chord2(idx_strip) = (1.0-f2)*chordl + f2*chordr
C
              rle_diff(1, idx_strip) = (1.0-fc)*xyzlel_diff(1) - (xyzlel
     +          (1)-xyzler(1))*fc_diff + fc*xyzler_diff(1)
              rle(1, idx_strip) = (1.0-fc)*xyzlel(1) + fc*xyzler(1)
              rle_diff(2, idx_strip) = (1.0-fc)*xyzlel_diff(2) - (xyzlel
     +          (2)-xyzler(2))*fc_diff + fc*xyzler_diff(2)
              rle(2, idx_strip) = (1.0-fc)*xyzlel(2) + fc*xyzler(2)
              rle_diff(3, idx_strip) = (1.0-fc)*xyzlel_diff(3) - (xyzlel
     +          (3)-xyzler(3))*fc_diff + fc*xyzler_diff(3)
              rle(3, idx_strip) = (1.0-fc)*xyzlel(3) + fc*xyzler(3)
              chord_diff(idx_strip) = (1.0-fc)*chordl_diff - (chordl-
     +          chordr)*fc_diff + fc*chordr_diff
              chord(idx_strip) = (1.0-fc)*chordl + fc*chordr
              IF (f2 - f1 .GE. 0.) THEN
                abs0_diff = f2_diff - f1_diff
                abs0 = f2 - f1
              ELSE
                abs0_diff = f1_diff - f2_diff
                abs0 = -(f2-f1)
              END IF
C
              wstrip_diff(idx_strip) = width*abs0_diff + abs0*width_diff
              wstrip(idx_strip) = abs0*width
              tanle(idx_strip) = (xyzler(1)-xyzlel(1))/width
              tante(idx_strip) = (xyzler(1)+chordr-xyzlel(1)-chordl)/
     +          width
C
Cc#ifdef USE_CPOML
              chsin = chsinl + f1*(chsinr-chsinl)
              chcos = chcosl + f1*(chcosr-chcosl)
              ainc1(idx_strip) = ATAN2(chsin, chcos)
              chsin = chsinl + f2*(chsinr-chsinl)
              chcos = chcosl + f2*(chcosr-chcosl)
              ainc2(idx_strip) = ATAN2(chsin, chcos)
C
Cc#endif
              chsin_diff = chsinl_diff + (chsinr-chsinl)*fc_diff + fc*(
     +          chsinr_diff-chsinl_diff)
              chsin = chsinl + fc*(chsinr-chsinl)
              chcos_diff = chcosl_diff + (chcosr-chcosl)*fc_diff + fc*(
     +          chcosr_diff-chcosl_diff)
              chcos = chcosl + fc*(chcosr-chcosl)
              ainc_diff(idx_strip) = chcos*chsin_diff/(chsin**2+chcos**2
     +          ) - chsin*chcos_diff/(chsin**2+chcos**2)
              ainc(idx_strip) = ATAN2(chsin, chcos)
C
              DO n=1,ndesign
                chsin_g_diff = (1.0-fc)*chsinl_g_diff(n) - (chsinl_g(n)-
     +            chsinr_g(n))*fc_diff + fc*chsinr_g_diff(n)
                chsin_g = (1.0-fc)*chsinl_g(n) + fc*chsinr_g(n)
                chcos_g_diff = (1.0-fc)*chcosl_g_diff(n) - (chcosl_g(n)-
     +            chcosr_g(n))*fc_diff + fc*chcosr_g_diff(n)
                chcos_g = (1.0-fc)*chcosl_g(n) + fc*chcosr_g(n)
                temp = chsin*chsin + chcos*chcos
                temp0 = (chcos*chsin_g-chsin*chcos_g)/temp
                ainc_g_diff(idx_strip, n) = (chsin_g*chcos_diff+chcos*
     +            chsin_g_diff-chcos_g*chsin_diff-chsin*chcos_g_diff-
     +            temp0*(2*chsin*chsin_diff+2*chcos*chcos_diff))/temp
                ainc_g(idx_strip, n) = temp0
              ENDDO
C
              DO n=1,ncontrol
                icl = isconl(n)
                icr = isconr(n)
C
                IF (icl .EQ. 0 .OR. icr .EQ. 0) THEN
C----------- no control effect here
                  gainda_diff(n) = 0.D0
                  gainda(n) = 0.
                  xled_diff(n) = 0.D0
                  xled(n) = 0.
                  xted_diff(n) = 0.D0
                  xted(n) = 0.
C
                  vhinge_diff(1, idx_strip, n) = 0.D0
                  vhinge(1, idx_strip, n) = 0.
                  vhinge_diff(2, idx_strip, n) = 0.D0
                  vhinge(2, idx_strip, n) = 0.
                  vhinge_diff(3, idx_strip, n) = 0.D0
                  vhinge(3, idx_strip, n) = 0.
C
                  vrefl(idx_strip, n) = 0.
C
                  phinge(1, idx_strip, n) = 0.
                  phinge(2, idx_strip, n) = 0.
                  phinge(3, idx_strip, n) = 0.
C
                ELSE
C----------- control variable # N is active here
                  gainda_diff(n) = (gaind(icr, isec+1, isurf)-gaind(icl
     +              , isec, isurf))*fc_diff
                  gainda(n) = gaind(icl, isec, isurf)*(1.0-fc) + gaind(
     +              icr, isec+1, isurf)*fc
C
                  xhd_diff = xhinged(icl, isec, isurf)*((1.0-fc)*
     +              chordl_diff-chordl*fc_diff) + xhinged(icr, isec+1, 
     +              isurf)*(fc*chordr_diff+chordr*fc_diff)
                  xhd = chordl*xhinged(icl, isec, isurf)*(1.0-fc) + 
     +              chordr*xhinged(icr, isec+1, isurf)*fc
                  IF (xhd .GE. 0.0) THEN
C------------ TE control surface, with hinge at XHD
                    xled_diff(n) = xhd_diff
                    xled(n) = xhd
                    xted_diff(n) = chord_diff(idx_strip)
                    xted(n) = chord(idx_strip)
                  ELSE
C------------ LE control surface, with hinge at -XHD
                    xled_diff(n) = 0.D0
                    xled(n) = 0.0
                    xted_diff(n) = -xhd_diff
                    xted(n) = -xhd
                  END IF
C
                  vhx_diff = vhinged(1, icl, isec, isurf)*xyzscal_diff(1
     +              , isurf)
                  vhx = vhinged(1, icl, isec, isurf)*xyzscal(1, isurf)
                  vhy_diff = vhinged(2, icl, isec, isurf)*xyzscal_diff(2
     +              , isurf)
                  vhy = vhinged(2, icl, isec, isurf)*xyzscal(2, isurf)
                  vhz_diff = vhinged(3, icl, isec, isurf)*xyzscal_diff(3
     +              , isurf)
                  vhz = vhinged(3, icl, isec, isurf)*xyzscal(3, isurf)
                  vsq_diff = 2*vhx*vhx_diff + 2*vhy*vhy_diff + 2*vhz*
     +              vhz_diff
                  vsq = vhx**2 + vhy**2 + vhz**2
                  IF (vsq .EQ. 0.0) THEN
                    IF (chordr*xhinged(icr, isec+1, isurf) .GE. 0.) THEN
                      abs1_diff = xhinged(icr, isec+1, isurf)*
     +                  chordr_diff
                      abs1 = chordr*xhinged(icr, isec+1, isurf)
                    ELSE
                      abs1_diff = -(xhinged(icr, isec+1, isurf)*
     +                  chordr_diff)
                      abs1 = -(chordr*xhinged(icr, isec+1, isurf))
                    END IF
                    IF (chordl*xhinged(icl, isec, isurf) .GE. 0.) THEN
                      abs2_diff = xhinged(icl, isec, isurf)*chordl_diff
                      abs2 = chordl*xhinged(icl, isec, isurf)
                    ELSE
                      abs2_diff = -(xhinged(icl, isec, isurf)*
     +                  chordl_diff)
                      abs2 = -(chordl*xhinged(icl, isec, isurf))
                    END IF
C------------ default: set hinge vector along hingeline
                    vhx_diff = xyzles_diff(1, isec+1, isurf) + abs1_diff
     +                - xyzles_diff(1, isec, isurf) - abs2_diff
                    vhx = xyzles(1, isec+1, isurf) + abs1 - xyzles(1, 
     +                isec, isurf) - abs2
                    vhy_diff = xyzles_diff(2, isec+1, isurf) - 
     +                xyzles_diff(2, isec, isurf)
                    vhy = xyzles(2, isec+1, isurf) - xyzles(2, isec, 
     +                isurf)
                    vhz_diff = xyzles_diff(3, isec+1, isurf) - 
     +                xyzles_diff(3, isec, isurf)
                    vhz = xyzles(3, isec+1, isurf) - xyzles(3, isec, 
     +                isurf)
                    vhx_diff = xyzscal(1, isurf)*vhx_diff + vhx*
     +                xyzscal_diff(1, isurf)
                    vhx = vhx*xyzscal(1, isurf)
                    vhy_diff = xyzscal(2, isurf)*vhy_diff + vhy*
     +                xyzscal_diff(2, isurf)
                    vhy = vhy*xyzscal(2, isurf)
                    vhz_diff = xyzscal(3, isurf)*vhz_diff + vhz*
     +                xyzscal_diff(3, isurf)
                    vhz = vhz*xyzscal(3, isurf)
                    vsq_diff = 2*vhx*vhx_diff + 2*vhy*vhy_diff + 2*vhz*
     +                vhz_diff
                    vsq = vhx**2 + vhy**2 + vhz**2
                  END IF
C
                  temp0 = SQRT(vsq)
                  IF (vsq .EQ. 0.D0) THEN
                    vmod_diff = 0.D0
                  ELSE
                    vmod_diff = vsq_diff/(2.0*temp0)
                  END IF
                  vmod = temp0
                  vhinge_diff(1, idx_strip, n) = (vhx_diff-vhx*vmod_diff
     +              /vmod)/vmod
                  vhinge(1, idx_strip, n) = vhx/vmod
                  vhinge_diff(2, idx_strip, n) = (vhy_diff-vhy*vmod_diff
     +              /vmod)/vmod
                  vhinge(2, idx_strip, n) = vhy/vmod
                  vhinge_diff(3, idx_strip, n) = (vhz_diff-vhz*vmod_diff
     +              /vmod)/vmod
                  vhinge(3, idx_strip, n) = vhz/vmod
C
                  vrefl(idx_strip, n) = refld(icl, isec, isurf)
C
                  IF (xhd .GE. 0.0) THEN
                    phinge(1, idx_strip, n) = rle(1, idx_strip) + xhd
                    phinge(2, idx_strip, n) = rle(2, idx_strip)
                    phinge(3, idx_strip, n) = rle(3, idx_strip)
                  ELSE
                    phinge(1, idx_strip, n) = rle(1, idx_strip) - xhd
                    phinge(2, idx_strip, n) = rle(2, idx_strip)
                    phinge(3, idx_strip, n) = rle(3, idx_strip)
                  END IF
                END IF
C

              ENDDO
C
C--- Interpolate CD-CL polar defining data from input sections to strips
              DO l=1,6
                clcd(l, idx_strip) = (1.0-fc)*clcdsec(l, isec, isurf) + 
     +            fc*clcdsec(l, isec+1, isurf)
              ENDDO
C--- If the min drag is zero flag the strip as no-viscous data
C     IJFRST(idx_strip) = NVOR + 1
              lviscstrp(idx_strip) = clcd(4, idx_strip) .NE. 0.0
C
C
              IF (idx_strip .EQ. 1) THEN
                ijfrst(idx_strip) = 1
              ELSE
                ijfrst(idx_strip) = ijfrst(idx_strip-1) + nvstrp(
     +            idx_strip-1)
              END IF
              nvstrp(idx_strip) = nvc(isurf)
C           write(*,*) 'IJFRST(idx_strip)', IJFRST(idx_strip),
C      &               'NVSTRP(idx_strip)', IJFRST(idx_strip - 1) + NVC(ISURF)
C
              lssurf(idx_strip) = isurf
C
              nsl = nasec(isec, isurf)
              nsr = nasec(isec+1, isurf)
C
              chordc_diff = chord_diff(idx_strip)
              chordc = chord(idx_strip)
C
              temp0 = (-fc+1.)/chordc
              temp = clafr/chordc
              clafc_diff = chordl*clafl*(-fc_diff-temp0*chordc_diff)/
     +          chordc + temp0*(clafl*chordl_diff+chordl*clafl_diff) + 
     +          temp*(chordr*fc_diff+fc*chordr_diff) + fc*chordr*(
     +          clafr_diff-temp*chordc_diff)/chordc
              clafc = temp0*(chordl*clafl) + fc*chordr*temp
C
C-------- set chordwise spacing fraction arrays
              CALL CSPACER_D(nvc(isurf), cspace(isurf), clafc, 
     +                       clafc_diff, xpt, xvr, xsr, xcp, xcp_diff)
C
C-------- go over vortices in this strip
              idx_vor = ijfrst(idx_strip)
C NVOR = NVOR + 1
C change all NVOR indices into idx_vor
C change all NSTRIP indices into idx_strip
              DO ivc=1,nvc(isurf)
C
                rv1_diff(1, idx_vor) = rle1_diff(1, idx_strip) + xvr(ivc
     +            )*chord1_diff(idx_strip)
                rv1(1, idx_vor) = rle1(1, idx_strip) + xvr(ivc)*chord1(
     +            idx_strip)
                rv1_diff(2, idx_vor) = rle1_diff(2, idx_strip)
                rv1(2, idx_vor) = rle1(2, idx_strip)
                rv1_diff(3, idx_vor) = rle1_diff(3, idx_strip)
                rv1(3, idx_vor) = rle1(3, idx_strip)
C
                rv2_diff(1, idx_vor) = rle2_diff(1, idx_strip) + xvr(ivc
     +            )*chord2_diff(idx_strip)
                rv2(1, idx_vor) = rle2(1, idx_strip) + xvr(ivc)*chord2(
     +            idx_strip)
                rv2_diff(2, idx_vor) = rle2_diff(2, idx_strip)
                rv2(2, idx_vor) = rle2(2, idx_strip)
                rv2_diff(3, idx_vor) = rle2_diff(3, idx_strip)
                rv2(3, idx_vor) = rle2(3, idx_strip)
C
                rv_diff(1, idx_vor) = rle_diff(1, idx_strip) + xvr(ivc)*
     +            chordc_diff
                rv(1, idx_vor) = rle(1, idx_strip) + xvr(ivc)*chordc
                rv_diff(2, idx_vor) = rle_diff(2, idx_strip)
                rv(2, idx_vor) = rle(2, idx_strip)
                rv_diff(3, idx_vor) = rle_diff(3, idx_strip)
                rv(3, idx_vor) = rle(3, idx_strip)
C
                rc_diff(1, idx_vor) = rle_diff(1, idx_strip) + chordc*
     +            xcp_diff(ivc) + xcp(ivc)*chordc_diff
                rc(1, idx_vor) = rle(1, idx_strip) + xcp(ivc)*chordc
                rc_diff(2, idx_vor) = rle_diff(2, idx_strip)
                rc(2, idx_vor) = rle(2, idx_strip)
                rc_diff(3, idx_vor) = rle_diff(3, idx_strip)
                rc(3, idx_vor) = rle(3, idx_strip)
C
                rs_diff(1, idx_vor) = rle_diff(1, idx_strip) + xsr(ivc)*
     +            chordc_diff
                rs(1, idx_vor) = rle(1, idx_strip) + xsr(ivc)*chordc
                rs_diff(2, idx_vor) = rle_diff(2, idx_strip)
                rs(2, idx_vor) = rle(2, idx_strip)
                rs_diff(3, idx_vor) = rle_diff(3, idx_strip)
                rs(3, idx_vor) = rle(3, idx_strip)
C
                CALL AKIMA_D(xasec(1, isec, isurf), xasec_diff(1, isec, 
     +                       isurf), sasec(1, isec, isurf), sasec_diff(1
     +                       , isec, isurf), nsl, xcp(ivc), xcp_diff(ivc
     +                       ), slopel, slopel_diff, dsdx)
                CALL AKIMA_D(xasec(1, isec+1, isurf), xasec_diff(1, isec
     +                       +1, isurf), sasec(1, isec+1, isurf), 
     +                       sasec_diff(1, isec+1, isurf), nsr, xcp(ivc)
     +                       , xcp_diff(ivc), sloper, sloper_diff, dsdx)
                temp0 = (-fc+1.)/chordc
                temp = sloper/chordc
                slopec_diff(idx_vor) = chordl*slopel*(-fc_diff-temp0*
     +            chordc_diff)/chordc + temp0*(slopel*chordl_diff+chordl
     +            *slopel_diff) + temp*(chordr*fc_diff+fc*chordr_diff) +
     +            fc*chordr*(sloper_diff-temp*chordc_diff)/chordc
                slopec(idx_vor) = temp0*(chordl*slopel) + fc*chordr*temp
C
                DO ii1=1,kcmax
                  xvr_diff(ii1) = 0.D0
                ENDDO
                CALL AKIMA_D(xasec(1, isec, isurf), xasec_diff(1, isec, 
     +                       isurf), sasec(1, isec, isurf), sasec_diff(1
     +                       , isec, isurf), nsl, xvr(ivc), xvr_diff(ivc
     +                       ), slopel, slopel_diff, dsdx)
                DO ii1=1,kcmax
                  xvr_diff(ii1) = 0.D0
                ENDDO
                CALL AKIMA_D(xasec(1, isec+1, isurf), xasec_diff(1, isec
     +                       +1, isurf), sasec(1, isec+1, isurf), 
     +                       sasec_diff(1, isec+1, isurf), nsr, xvr(ivc)
     +                       , xvr_diff(ivc), sloper, sloper_diff, dsdx)
                temp0 = (-fc+1.)/chordc
                temp = sloper/chordc
                slopev_diff(idx_vor) = chordl*slopel*(-fc_diff-temp0*
     +            chordc_diff)/chordc + temp0*(slopel*chordl_diff+chordl
     +            *slopel_diff) + temp*(chordr*fc_diff+fc*chordr_diff) +
     +            fc*chordr*(sloper_diff-temp*chordc_diff)/chordc
                slopev(idx_vor) = temp0*(chordl*slopel) + fc*chordr*temp
C
                dxoc = xpt(ivc+1) - xpt(ivc)
                dxv_diff(idx_vor) = dxoc*chordc_diff
                dxv(idx_vor) = dxoc*chordc
                chordv_diff(idx_vor) = chordc_diff
                chordv(idx_vor) = chordc
                lvcomp(idx_vor) = lncomp(isurf)
C
                lvnc(idx_vor) = .true.
C
C---------- element inherits alpha,beta flag from surface
                lvalbe(idx_vor) = lfalbe(isurf)
C
                DO n=1,ncontrol
C------------ scale control gain by factor 0..1, (fraction of element on control surface)
                  temp0 = xled(n)/chordc
                  fracle_diff = (xled_diff(n)-temp0*chordc_diff)/(dxoc*
     +              chordc)
                  fracle = (temp0-xpt(ivc))/dxoc
                  temp0 = xted(n)/chordc
                  fracte_diff = (xted_diff(n)-temp0*chordc_diff)/(dxoc*
     +              chordc)
                  fracte = (temp0-xpt(ivc))/dxoc
                  IF (0.0 .LT. fracle) THEN
                    y1_diff = fracle_diff
                    y1 = fracle
                  ELSE
                    y1 = 0.0
                    y1_diff = 0.D0
                  END IF
                  IF (1.0 .GT. y1) THEN
                    fracle_diff = y1_diff
                    fracle = y1
                  ELSE
                    fracle = 1.0
                    fracle_diff = 0.D0
                  END IF
                  IF (0.0 .LT. fracte) THEN
                    y2_diff = fracte_diff
                    y2 = fracte
                  ELSE
                    y2 = 0.0
                    y2_diff = 0.D0
                  END IF
                  IF (1.0 .GT. y2) THEN
                    fracte_diff = y2_diff
                    fracte = y2
                  ELSE
                    fracte = 1.0
                    fracte_diff = 0.D0
                  END IF
C
                  dcontrol_diff(idx_vor, n) = (fracte-fracle)*
     +              gainda_diff(n) + gainda(n)*(fracte_diff-fracle_diff)
                  dcontrol(idx_vor, n) = gainda(n)*(fracte-fracle)
                ENDDO
C
C---------- TE control point used only if surface sheds a wake
                lvnc(idx_vor) = lfwake(isurf)
C
Cc#ifdef USE_CPOML
C...        nodal grid associated with vortex strip (aft-panel nodes)
C...        NOTE: airfoil in plane of wing, but not rotated perpendicular to dihedral;
C...        retained in (x,z) plane at this point
                CALL AKIMA(xlasec(1, isec, isurf), zlasec(1, isec, isurf
     +                     ), nsl, xpt(ivc+1), zl_l, dsdx)
                CALL AKIMA(xuasec(1, isec, isurf), zuasec(1, isec, isurf
     +                     ), nsl, xpt(ivc+1), zu_l, dsdx)
C
                CALL AKIMA(xlasec(1, isec+1, isurf), zlasec(1, isec+1, 
     +                     isurf), nsr, xpt(ivc+1), zl_r, dsdx)
                CALL AKIMA(xuasec(1, isec+1, isurf), zuasec(1, isec+1, 
     +                     isurf), nsr, xpt(ivc+1), zu_r, dsdx)
C
                xyn1(1, idx_vor) = rle1(1, idx_strip) + xpt(ivc+1)*
     +            chord1(idx_strip)
                xyn1(2, idx_vor) = rle1(2, idx_strip)
                zl = (1.-f1)*zl_l + f1*zl_r
                zu = (1.-f1)*zu_l + f1*zu_r
                zlon1(idx_vor) = rle1(3, idx_strip) + zl*chord1(
     +            idx_strip)
                zupn1(idx_vor) = rle1(3, idx_strip) + zu*chord1(
     +            idx_strip)
C
                xyn2(1, idx_vor) = rle2(1, idx_strip) + xpt(ivc+1)*
     +            chord2(idx_strip)
                xyn2(2, idx_vor) = rle2(2, idx_strip)
                zl = (1.-f2)*zl_l + f2*zl_r
                zu = (1.-f2)*zu_l + f2*zu_r
                zlon2(idx_vor) = rle2(3, idx_strip) + zl*chord2(
     +            idx_strip)
                zupn2(idx_vor) = rle2(3, idx_strip) + zu*chord2(
     +            idx_strip)
C
Cc#endif
                idx_vor = idx_vor + 1
              ENDDO
C           
              idx_strip = idx_strip + 1
            ENDDO
          ENDDO
C
C
C---- Find wetted surface area (one side)
          sum = 0.0
          wtot = 0.0
          DO jj=1,nj(isurf)
            j = jfrst(isurf) + jj - 1
            astrp = wstrip(j)*chord(j)
            sum = sum + astrp
            wtot = wtot + wstrip(j)
          ENDDO
          ssurf(isurf) = sum
C
          IF (wtot .EQ. 0.0) THEN
            cavesurf(isurf) = 0.0
          ELSE
            cavesurf(isurf) = sum/wtot
          END IF
C     add number of strips to the global count
          nstrip = nstrip + nj(isurf)
C     add number of of votrices
          nvor = nvor + nk(isurf)*nj(isurf)
C
          RETURN
        END IF
      END IF
C
 7000 FORMAT(/' *** Cannot adjust spanwise spacing at section',i3,
     +       ', on surface ',a/
     +      ' *** Insufficient number of spanwise vortices to work with'
     +      )
      END

C  Differentiation of makesurf_mesh in forward (tangent) mode (with options i4 dr8 r8):
C   variations   of useful results: rv1msh rv2msh rvmsh rcmsh rle
C                chord rle1 chord1 rle2 chord2 wstrip ainc ainc_g
C                rv1 rv2 rv rc rs dxv chordv slopev slopec dcontrol
C                vhinge
C   with respect to varying inputs: xyzscal xyztran addinc aincs
C                xasec sasec claf mshblk rv1msh rv2msh rvmsh rcmsh
C                rle chord rle1 chord1 rle2 chord2 wstrip ainc
C                ainc_g rv1 rv2 rv rc rs dxv chordv slopev slopec
C                dcontrol vhinge
C
      SUBROUTINE MAKESURF_MESH_D(isurf)
      INCLUDE 'AVL.INC'
      INCLUDE 'AVL_ad_seeds.inc'
C working variables (AVL original)
      INTEGER isurf
      INTEGER kcmax
      INTEGER ksmax
      PARAMETER (kcmax=50, ksmax=500)
      REAL chsin, chcos, chsinl, chsinr, chcosl, chcosr, aincl, aincr, 
     +     chordl, chordr, clafl, clafr, slopel, sloper, dxdx, zu_l, 
     +     zl_l, zu_r, zl_r, zl, zr, sum, wtot, astrp
      REAL chsin_diff, chcos_diff, chsinl_diff, chsinr_diff, chcosl_diff
     +     , chcosr_diff, aincl_diff, aincr_diff, chordl_diff, 
     +     chordr_diff, clafl_diff, clafr_diff, slopel_diff, sloper_diff
      REAL chsinl_g(ngmax), chcosl_g(ngmax), chsinr_g(ngmax), chcosr_g(
     +     ngmax), xled(ndmax), xted(ndmax), gainda(ndmax)
      REAL chsinl_g_diff(ngmax), chcosl_g_diff(ngmax), chsinr_g_diff(
     +     ngmax), chcosr_g_diff(ngmax), xled_diff(ndmax), xted_diff(
     +     ndmax)
C working variables (OptVL additions)
      INTEGER isconl(ndmax), isconr(ndmax)
      REAL m1, m2, m3, f1, f2, fc, dc1, dc2, dc, a1, a2, a3, xptxind1, 
     +     xptxind2
      REAL m2_diff, m3_diff, dc1_diff, dc2_diff, a1_diff, a2_diff, 
     +     a3_diff
      REAL mesh_surf(3, (nvc(isurf)+1)*(nvs(isurf)+1))
      REAL mesh_surf_diff(3, (nvc(isurf)+1)*(nvs(isurf)+1))
C functions
      INTEGER idx_vor, idx_strip, idx_sec, idx_dim, idx_coef, idx_x, 
     +        idx_node, idx_nodel, idx_noder, idx_node_yp1, idx_node_nx
     +        , idx_node_nx_yp1, idx_y, nx, ny
C
C Get data from common block
      INTEGER FLATIDX
      INTEGER isec
      INTEGER ii
      INTEGER ispan
      INTEGER iptl
      INTEGER iptr
      INTRINSIC SQRT
      INTRINSIC SIN
      INTRINSIC COS
      INTEGER n
      INTEGER iscon
      INTEGER isdes
      INTRINSIC ATAN2
      REAL chsin_g
      REAL chsin_g_diff
      REAL chcos_g
      REAL chcos_g_diff
      INTEGER icl
      INTEGER icr
      REAL xhd
      REAL xhd_diff
      REAL vhx
      REAL vhx_diff
      REAL vhy
      REAL vhy_diff
      REAL vhz
      REAL vhz_diff
      REAL vsq
      REAL vsq_diff
      INTRINSIC ABS
      REAL vmod
      REAL vmod_diff
      INTEGER nsl
      INTEGER nsr
      REAL clafc
      REAL clafc_diff
      REAL dx1
      REAL dx1_diff
      REAL dx2
      REAL dx2_diff
      REAL dx3
      REAL dx3_diff
      REAL dsdx
      REAL xpt
      REAL xpt_diff
      REAL fracle
      REAL fracle_diff
      REAL fracte
      REAL fracte_diff
      INTRINSIC MAX
      INTRINSIC MIN
      REAL zu
      INTEGER jj
      INTEGER j
      REAL y1
      REAL y1_diff
      REAL y2
      REAL y2_diff
      REAL(kind=avl_real) abs0
      REAL(kind=avl_real) abs0_diff
      REAL(kind=avl_real) abs1
      REAL(kind=avl_real) abs1_diff
      REAL arg1
      REAL arg1_diff
      REAL arg2
      REAL arg2_diff
      REAL(kind=avl_real) arg10
      REAL(kind=avl_real) arg10_diff
      REAL temp
      REAL temp0
      REAL(kind=avl_real) temp1
      REAL(kind=avl_real) temp2
C
      nx = nvc(isurf) + 1
C Check MFRST
      ny = nvs(isurf) + 1
C Get the mesh for this surface from the the common block
C
      IF (mfrst(isurf) .EQ. 0) PRINT*, 
     +           '* Provide the index where the mesh begins for surface'
     +                               , isurf
C
C Perform input checks from makesurf (section check removed)
      mesh_surf_diff = mshblk_diff(:, mfrst(isurf):mfrst(isurf)+nx*ny-1)
      mesh_surf = mshblk(:, mfrst(isurf):mfrst(isurf)+nx*ny-1)
C
C
      IF (nvc(isurf) .GT. kcmax) THEN
        WRITE(*, *) 
     +        '* makesurf_mesh: Array overflow.  Increase KCMAX to', nvc
     +        (isurf)
        nvc(isurf) = kcmax
      END IF
C Image flag set to indicate section definition direction
C IMAGS= 1  defines edge 1 located at surface root edge 
C IMAGS=-1  defines edge 2 located at surface root edge (reflected surfaces)
C
      IF (nvs(isurf) .GT. ksmax) THEN
        WRITE(*, *) 
     +        '* makesurf_mesh: Array overflow.  Increase KSMAX to', nvs
     +        (isurf)
        nvs(isurf) = ksmax
      END IF
C
C Start accumulating the element and strip index references
C Accumulate the first element in surface
      imags(isurf) = 1
C Accumulate the first strip in surface
      IF (isurf .EQ. 1) THEN
        ifrst(isurf) = 1
      ELSE
        ifrst(isurf) = ifrst(isurf-1) + nk(isurf-1)*nj(isurf-1)
      END IF
C Set NK from input data (python layer will ensure this is consistent)
C
      IF (isurf .EQ. 1) THEN
        jfrst(isurf) = 1
      ELSE
        jfrst(isurf) = jfrst(isurf-1) + nj(isurf-1)
      END IF
C We need to start counting strips now since it is a global count
      nk(isurf) = nvc(isurf)
C
C Bypass the entire spanwise node generation routine and go straight to store counters
C skips MAKESURF 94-234
C Index of first strip in surface
C This is normally used to store the index of each section in AVL
C but since we use strips now each is effectively just a section
C We assign this variable accordingly so as not to break anything else
      idx_strip = jfrst(isurf)
C Number of strips/sections in surface
C
      IF (isurf .EQ. 1) THEN
        icntfrst(isurf) = 1
      ELSE
        icntfrst(isurf) = icntfrst(isurf-1) + ncntsec(isurf-1)
      END IF
C Store the spanwise index of each strip in each surface
      ncntsec(isurf) = nsec(isurf)
      DO isec=1,nsec(isurf)
        ii = icntfrst(isurf) + (isec-1)
        icntsec(ii) = idx_strip
C Apply the scaling and translations to the mesh as a whole
      ENDDO
C
C
      DO idx_y=1,ny
        DO idx_x=1,nx
          DO idx_dim=1,3
            idx_node = FLATIDX(idx_x, idx_y, isurf)
            mesh_surf_diff(idx_dim, idx_node) = mesh_surf(idx_dim, 
     +        idx_node)*xyzscal_diff(idx_dim, isurf) + xyzscal(idx_dim, 
     +        isurf)*mesh_surf_diff(idx_dim, idx_node) + xyztran_diff(
     +        idx_dim, isurf)
            mesh_surf(idx_dim, idx_node) = xyzscal(idx_dim, isurf)*
     +        mesh_surf(idx_dim, idx_node) + xyztran(idx_dim, isurf)
          ENDDO
        ENDDO
C Setup the strips
C Set spanwise elements to 0

      ENDDO
C
C
C
C Check control and design vars
      nj(isurf) = 0
C
      IF (ncontrol .GT. ndmax) THEN
        WRITE(*, *) '*** Too many control variables.  Increase NDMAX to'
     +        , ncontrol
        STOP
      ELSE IF (ndesign .GT. ngmax) THEN
C Instead of looping over sections just loop over all strips in the surface
C
        WRITE(*, *) '*** Too many design variables.  Increase NGMAX to'
     +        , ndesign
        STOP
      ELSE
        chcosl_g_diff = 0.D0
        chsinr_g_diff = 0.D0
        xted_diff = 0.D0
        xled_diff = 0.D0
        chsinl_g_diff = 0.D0
        chcosr_g_diff = 0.D0
C
Cispan loop
C Set reference information for the strip
C This code was used in the original to loop over strips in a section. 
C We will just reuse the variables here 
        DO ispan=1,ny-1
C
C
          idx_y = idx_strip - jfrst(isurf) + 1
          iptl = idx_y
          iptr = idx_y + 1
C We need to compute the chord and claf values at the left and right edge of the strip
C This code was used in the original to interpolate over sections. 
C We will just reuse here to interpolate over a strip which is trivial but avoids pointless code rewrites.
          nj(isurf) = nj(isurf) + 1
C
C
          idx_node = FLATIDX(1, iptl, isurf)
          idx_node_nx = FLATIDX(nx, iptl, isurf)
          temp = mesh_surf(1, idx_node_nx) - mesh_surf(1, idx_node)
          temp0 = mesh_surf(3, idx_node_nx) - mesh_surf(3, idx_node)
          arg1_diff = 2*temp*(mesh_surf_diff(1, idx_node_nx)-
     +      mesh_surf_diff(1, idx_node)) + 2*temp0*(mesh_surf_diff(3, 
     +      idx_node_nx)-mesh_surf_diff(3, idx_node))
          arg1 = temp*temp + temp0*temp0
          temp0 = SQRT(arg1)
          IF (arg1 .EQ. 0.D0) THEN
            chordl_diff = 0.D0
          ELSE
            chordl_diff = arg1_diff/(2.0*temp0)
          END IF
          chordl = temp0
          idx_node = FLATIDX(1, iptr, isurf)
          idx_node_nx = FLATIDX(nx, iptr, isurf)
          temp0 = mesh_surf(1, idx_node_nx) - mesh_surf(1, idx_node)
          temp = mesh_surf(3, idx_node_nx) - mesh_surf(3, idx_node)
          arg1_diff = 2*temp0*(mesh_surf_diff(1, idx_node_nx)-
     +      mesh_surf_diff(1, idx_node)) + 2*temp*(mesh_surf_diff(3, 
     +      idx_node_nx)-mesh_surf_diff(3, idx_node))
          arg1 = temp0*temp0 + temp*temp
          temp0 = SQRT(arg1)
          IF (arg1 .EQ. 0.D0) THEN
            chordr_diff = 0.D0
          ELSE
            chordr_diff = arg1_diff/(2.0*temp0)
          END IF
          chordr = temp0
          clafl_diff = claf_diff(iptl, isurf)
          clafl = claf(iptl, isurf)
C Linearly interpolate the incidence projections over the STRIP
          clafr_diff = claf_diff(iptr, isurf)
          clafr = claf(iptr, isurf)
C
          aincl_diff = dtr*aincs_diff(iptl, isurf) + dtr*addinc_diff(
     +      isurf)
          aincl = aincs(iptl, isurf)*dtr + addinc(isurf)*dtr
          aincr_diff = dtr*aincs_diff(iptr, isurf) + dtr*addinc_diff(
     +      isurf)
          aincr = aincs(iptr, isurf)*dtr + addinc(isurf)*dtr
          temp0 = SIN(aincl)
          chsinl_diff = temp0*chordl_diff + chordl*COS(aincl)*aincl_diff
          chsinl = chordl*temp0
          temp0 = SIN(aincr)
          chsinr_diff = temp0*chordr_diff + chordr*COS(aincr)*aincr_diff
          chsinr = chordr*temp0
          temp0 = COS(aincl)
          chcosl_diff = temp0*chordl_diff - chordl*SIN(aincl)*aincl_diff
          chcosl = chordl*temp0
C We need to determine which controls belong to this section 
C Bring over the routine for this from makesurf but do it for each strip now
          temp0 = COS(aincr)
          chcosr_diff = temp0*chordr_diff - chordr*SIN(aincr)*aincr_diff
          chcosr = chordr*temp0
C
          DO n=1,ncontrol
            isconl(n) = 0
            isconr(n) = 0
            DO iscon=1,nscon(iptl, isurf)
              IF (icontd(iscon, iptl, isurf) .EQ. n) isconl(n) = iscon
            ENDDO
            DO iscon=1,nscon(iptr, isurf)
              IF (icontd(iscon, iptr, isurf) .EQ. n) isconr(n) = iscon
            ENDDO
C We need to determine which dvs belong to this strip 
C and setup the chord projection gains
C Bring over the routine for this from makesurf but setup for strips

          ENDDO
C
          DO n=1,ndesign
            chsinl_g_diff(n) = 0.D0
            chsinl_g(n) = 0.
            chsinr_g_diff(n) = 0.D0
            chsinr_g(n) = 0.
            chcosl_g_diff(n) = 0.D0
            chcosl_g(n) = 0.
            chcosr_g_diff(n) = 0.D0
            chcosr_g(n) = 0.
C
            DO isdes=1,nsdes(iptl, isurf)
              IF (idestd(isdes, iptl, isurf) .EQ. n) THEN
                chsinl_g_diff(n) = gaing(isdes, iptl, isurf)*dtr*
     +            chcosl_diff
                chsinl_g(n) = chcosl*gaing(isdes, iptl, isurf)*dtr
                chcosl_g_diff(n) = -(gaing(isdes, iptl, isurf)*dtr*
     +            chsinl_diff)
                chcosl_g(n) = -(chsinl*gaing(isdes, iptl, isurf)*dtr)
              END IF
            ENDDO
C
            DO isdes=1,nsdes(iptr, isurf)
              IF (idestd(isdes, iptr, isurf) .EQ. n) THEN
                chsinr_g_diff(n) = gaing(isdes, iptr, isurf)*dtr*
     +            chcosr_diff
                chsinr_g(n) = chcosr*gaing(isdes, iptr, isurf)*dtr
                chcosr_g_diff(n) = -(gaing(isdes, iptr, isurf)*dtr*
     +            chsinr_diff)
                chcosr_g(n) = -(chsinr*gaing(isdes, iptr, isurf)*dtr)
              END IF
            ENDDO
C Set the strip geometry data
C Note these computations assume the mesh is not necessarily planar
C ultimately if/when we flatten the mesh into a planar one we will want
C to use the leading edge positions and chords from the original input mesh
C Strip left side

          ENDDO
C
C
C
          idx_node = FLATIDX(1, idx_y, isurf)
          idx_node_nx = FLATIDX(nx, idx_y, isurf)
          DO idx_dim=1,3
            rle1_diff(idx_dim, idx_strip) = mesh_surf_diff(idx_dim, 
     +        idx_node)
            rle1(idx_dim, idx_strip) = mesh_surf(idx_dim, idx_node)
          ENDDO
C
C Strip right side
          temp0 = mesh_surf(1, idx_node_nx) - mesh_surf(1, idx_node)
          temp = mesh_surf(3, idx_node_nx) - mesh_surf(3, idx_node)
          arg1_diff = 2*temp0*(mesh_surf_diff(1, idx_node_nx)-
     +      mesh_surf_diff(1, idx_node)) + 2*temp*(mesh_surf_diff(3, 
     +      idx_node_nx)-mesh_surf_diff(3, idx_node))
          arg1 = temp0*temp0 + temp*temp
          temp0 = SQRT(arg1)
          IF (arg1 .EQ. 0.D0) THEN
            chord1_diff(idx_strip) = 0.D0
          ELSE
            chord1_diff(idx_strip) = arg1_diff/(2.0*temp0)
          END IF
          chord1(idx_strip) = temp0
C
          idx_node_yp1 = FLATIDX(1, idx_y + 1, isurf)
          idx_node_nx_yp1 = FLATIDX(nx, idx_y + 1, isurf)
          DO idx_dim=1,3
            rle2_diff(idx_dim, idx_strip) = mesh_surf_diff(idx_dim, 
     +        idx_node_yp1)
            rle2(idx_dim, idx_strip) = mesh_surf(idx_dim, idx_node_yp1)
          ENDDO
C Strip mid-point 
          temp0 = mesh_surf(1, idx_node_nx_yp1) - mesh_surf(1, 
     +      idx_node_yp1)
          temp = mesh_surf(3, idx_node_nx_yp1) - mesh_surf(3, 
     +      idx_node_yp1)
          arg1_diff = 2*temp0*(mesh_surf_diff(1, idx_node_nx_yp1)-
     +      mesh_surf_diff(1, idx_node_yp1)) + 2*temp*(mesh_surf_diff(3
     +      , idx_node_nx_yp1)-mesh_surf_diff(3, idx_node_yp1))
          arg1 = temp0*temp0 + temp*temp
          temp0 = SQRT(arg1)
          IF (arg1 .EQ. 0.D0) THEN
            chord2_diff(idx_strip) = 0.D0
          ELSE
            chord2_diff(idx_strip) = arg1_diff/(2.0*temp0)
          END IF
          chord2(idx_strip) = temp0
C
C Since the strips are linear SPANWISE we can just interpolate
          DO idx_dim=1,3
            rle_diff(idx_dim, idx_strip) = (rle1_diff(idx_dim, idx_strip
     +        )+rle2_diff(idx_dim, idx_strip))/2.
            rle(idx_dim, idx_strip) = (rle1(idx_dim, idx_strip)+rle2(
     +        idx_dim, idx_strip))/2.
C The strips are not necessarily linear chord wise but by definition the chord value is
C so we can interpolate
          ENDDO
C Strip geometric incidence angle at the mid-point
C This is strip incidence angle is computed from the LE and TE points
C of the given geometry and is completely independent of AINC
C This quantity is needed to correctly handle nonplanar meshes and is only needed if the mesh isnt flattened
          chord_diff(idx_strip) = (chord1_diff(idx_strip)+chord2_diff(
     +      idx_strip))/2.
          chord(idx_strip) = (chord1(idx_strip)+chord2(idx_strip))/2.
C
C Strip width
          arg1 = (mesh_surf(3, idx_node_nx)+mesh_surf(3, idx_node_nx_yp1
     +      ))/2. - (mesh_surf(3, idx_node)+mesh_surf(3, idx_node_yp1))/
     +      2.
          arg2 = (mesh_surf(1, idx_node_nx)+mesh_surf(1, idx_node_nx_yp1
     +      ))/2. - (mesh_surf(1, idx_node)+mesh_surf(1, idx_node_yp1))/
     +      2.
          gincstrip(idx_strip) = ATAN2(arg1, arg2)
C
          m2_diff = mesh_surf_diff(2, idx_node_yp1) - mesh_surf_diff(2, 
     +      idx_node)
          m2 = mesh_surf(2, idx_node_yp1) - mesh_surf(2, idx_node)
          m3_diff = mesh_surf_diff(3, idx_node_yp1) - mesh_surf_diff(3, 
     +      idx_node)
          m3 = mesh_surf(3, idx_node_yp1) - mesh_surf(3, idx_node)
C Strip LE and TE sweep slopes
          arg1_diff = 2*m2*m2_diff + 2*m3*m3_diff
          arg1 = m2**2 + m3**2
          temp0 = SQRT(arg1)
          IF (arg1 .EQ. 0.D0) THEN
            wstrip_diff(idx_strip) = 0.D0
          ELSE
            wstrip_diff(idx_strip) = arg1_diff/(2.0*temp0)
          END IF
          wstrip(idx_strip) = temp0
C
          tanle(idx_strip) = (mesh_surf(1, idx_node_yp1)-mesh_surf(1, 
     +      idx_node))/wstrip(idx_strip)
          idx_node = FLATIDX(nx, idx_y, isurf)
          idx_node_yp1 = FLATIDX(nx, idx_y + 1, isurf)
C Compute chord projections and strip twists
C In AVL the AINCS are not interpolated. The chord projections are
C So we have to replicate this effect.
C LINEAR interpolation over the strip: left, right, and midpoint
          tante(idx_strip) = (mesh_surf(1, idx_node_yp1)-mesh_surf(1, 
     +      idx_node))/wstrip(idx_strip)
C
C
          idx_nodel = FLATIDX(1, iptl, isurf)
C       f1 = (mesh_surf(2,idx_node)-mesh_surf(2,idx_nodel))/
C      & (mesh_surf(2,idx_noder)-mesh_surf(2,idx_nodel))
C       f2 = (mesh_surf(2,idx_node_yp1)-mesh_surf(2,idx_nodel))/
C      & (mesh_surf(2,idx_noder)-mesh_surf(2,idx_nodel))
C       fc = (((mesh_surf(2,idx_node_yp1)+mesh_surf(2,idx_node))/2.) 
C      & -mesh_surf(2,idx_nodel))/(mesh_surf(2,idx_noder)
C      & -mesh_surf(2,idx_nodel))
C the above expressions will always evaluate to the following for individual strips
          idx_noder = FLATIDX(1, iptr, isurf)
C
C
          f1 = 0.0
          f2 = 1.0
C Strip left side incidence
C CHSIN = CHSINL + f1*(CHSINR-CHSINL)
C CHCOS = CHCOSL + f1*(CHCOSR-CHCOSL)
          fc = 0.5
C
C Strip right side incidence
C CHSIN = CHSINL + f2*(CHSINR-CHSINL)
C CHCOS = CHCOSL + f2*(CHCOSR-CHCOSL)
          ainc1(idx_strip) = ATAN2(chsinl, chcosl)
C
C Strip mid-point incidence
          ainc2(idx_strip) = ATAN2(chsinr, chcosr)
C
          chsin_diff = chsinl_diff + fc*(chsinr_diff-chsinl_diff)
          chsin = chsinl + fc*(chsinr-chsinl)
          chcos_diff = chcosl_diff + fc*(chcosr_diff-chcosl_diff)
          chcos = chcosl + fc*(chcosr-chcosl)
C Set dv gains for incidence angles
C Bring over the routine for this from make surf
          ainc_diff(idx_strip) = chcos*chsin_diff/(chsin**2+chcos**2) - 
     +      chsin*chcos_diff/(chsin**2+chcos**2)
          ainc(idx_strip) = ATAN2(chsin, chcos)
C
          DO n=1,ndesign
            chsin_g_diff = (1.0-fc)*chsinl_g_diff(n) + fc*chsinr_g_diff(
     +        n)
            chsin_g = (1.0-fc)*chsinl_g(n) + fc*chsinr_g(n)
            chcos_g_diff = (1.0-fc)*chcosl_g_diff(n) + fc*chcosr_g_diff(
     +        n)
            chcos_g = (1.0-fc)*chcosl_g(n) + fc*chcosr_g(n)
            temp0 = chsin*chsin + chcos*chcos
            temp = (chcos*chsin_g-chsin*chcos_g)/temp0
            ainc_g_diff(idx_strip, n) = (chsin_g*chcos_diff+chcos*
     +        chsin_g_diff-chcos_g*chsin_diff-chsin*chcos_g_diff-temp*(2
     +        *chsin*chsin_diff+2*chcos*chcos_diff))/temp0
            ainc_g(idx_strip, n) = temp
C We have to now setup any control surfaces we defined for this strip
C Bring over the routine for this from makesurf but modified for a strip
          ENDDO
C
          DO n=1,ncontrol
            icl = isconl(n)
            icr = isconr(n)
C
            IF (icl .EQ. 0 .OR. icr .EQ. 0) THEN
C no control effect here
              gainda(n) = 0.
              xled_diff(n) = 0.D0
              xled(n) = 0.
              xted_diff(n) = 0.D0
              xted(n) = 0.
C
              vhinge_diff(1, idx_strip, n) = 0.D0
              vhinge(1, idx_strip, n) = 0.
              vhinge_diff(2, idx_strip, n) = 0.D0
              vhinge(2, idx_strip, n) = 0.
              vhinge_diff(3, idx_strip, n) = 0.D0
              vhinge(3, idx_strip, n) = 0.
C
              vrefl(idx_strip, n) = 0.
C
              phinge(1, idx_strip, n) = 0.
              phinge(2, idx_strip, n) = 0.
              phinge(3, idx_strip, n) = 0.
C
            ELSE
C control variable # N is active here
C SAB Note: This interpolation ensures that the hinge line is 
C is linear which I think it is an ok assumption for arbitrary wings as long as the user is aware
C A curve hinge line could work if needed if we just interpolate XHINGED and scaled by local chord
              gainda(n) = gaind(icl, iptl, isurf)*(1.0-fc) + gaind(icr, 
     +          iptr, isurf)*fc
C
              xhd_diff = xhinged(icl, iptl, isurf)*(1.0-fc)*chordl_diff 
     +          + xhinged(icr, iptr, isurf)*fc*chordr_diff
              xhd = chordl*xhinged(icl, iptl, isurf)*(1.0-fc) + chordr*
     +          xhinged(icr, iptr, isurf)*fc
              IF (xhd .GE. 0.0) THEN
C TE control surface, with hinge at XHD
                xled_diff(n) = xhd_diff
                xled(n) = xhd
                xted_diff(n) = chord_diff(idx_strip)
                xted(n) = chord(idx_strip)
              ELSE
C LE control surface, with hinge at -XHD
                xled_diff(n) = 0.D0
                xled(n) = 0.0
                xted_diff(n) = -xhd_diff
                xted(n) = -xhd
              END IF
C
              vhx_diff = vhinged(1, icl, iptl, isurf)*xyzscal_diff(1, 
     +          isurf)
              vhx = vhinged(1, icl, iptl, isurf)*xyzscal(1, isurf)
              vhy_diff = vhinged(2, icl, iptl, isurf)*xyzscal_diff(2, 
     +          isurf)
              vhy = vhinged(2, icl, iptl, isurf)*xyzscal(2, isurf)
              vhz_diff = vhinged(3, icl, iptl, isurf)*xyzscal_diff(3, 
     +          isurf)
              vhz = vhinged(3, icl, iptl, isurf)*xyzscal(3, isurf)
              vsq_diff = 2*vhx*vhx_diff + 2*vhy*vhy_diff + 2*vhz*
     +          vhz_diff
              vsq = vhx**2 + vhy**2 + vhz**2
              IF (vsq .EQ. 0.0) THEN
                IF (chordr*xhinged(icr, iptr, isurf) .GE. 0.) THEN
                  abs0_diff = xhinged(icr, iptr, isurf)*chordr_diff
                  abs0 = chordr*xhinged(icr, iptr, isurf)
                ELSE
                  abs0_diff = -(xhinged(icr, iptr, isurf)*chordr_diff)
                  abs0 = -(chordr*xhinged(icr, iptr, isurf))
                END IF
                IF (chordl*xhinged(icl, iptl, isurf) .GE. 0.) THEN
                  abs1_diff = xhinged(icl, iptl, isurf)*chordl_diff
                  abs1 = chordl*xhinged(icl, iptl, isurf)
                ELSE
                  abs1_diff = -(xhinged(icl, iptl, isurf)*chordl_diff)
                  abs1 = -(chordl*xhinged(icl, iptl, isurf))
                END IF
C default: set hinge vector along hingeline
C We are just setting the hinge line across the section
C this assumes the hinge is linear even for a nonlinear wing
                vhx_diff = mesh_surf_diff(1, idx_noder) + abs0_diff - 
     +            mesh_surf_diff(1, idx_nodel) - abs1_diff
                vhx = mesh_surf(1, idx_noder) + abs0 - mesh_surf(1, 
     +            idx_nodel) - abs1
                vhy_diff = mesh_surf_diff(2, idx_noder) - mesh_surf_diff
     +            (2, idx_nodel)
                vhy = mesh_surf(2, idx_noder) - mesh_surf(2, idx_nodel)
                vhz_diff = mesh_surf_diff(3, idx_noder) - mesh_surf_diff
     +            (3, idx_nodel)
                vhz = mesh_surf(3, idx_noder) - mesh_surf(3, idx_nodel)
                vhx_diff = xyzscal(1, isurf)*vhx_diff + vhx*xyzscal_diff
     +            (1, isurf)
                vhx = vhx*xyzscal(1, isurf)
                vhy_diff = xyzscal(2, isurf)*vhy_diff + vhy*xyzscal_diff
     +            (2, isurf)
                vhy = vhy*xyzscal(2, isurf)
                vhz_diff = xyzscal(3, isurf)*vhz_diff + vhz*xyzscal_diff
     +            (3, isurf)
                vhz = vhz*xyzscal(3, isurf)
                vsq_diff = 2*vhx*vhx_diff + 2*vhy*vhy_diff + 2*vhz*
     +            vhz_diff
                vsq = vhx**2 + vhy**2 + vhz**2
              END IF
C
              temp0 = SQRT(vsq)
              IF (vsq .EQ. 0.D0) THEN
                vmod_diff = 0.D0
              ELSE
                vmod_diff = vsq_diff/(2.0*temp0)
              END IF
              vmod = temp0
              vhinge_diff(1, idx_strip, n) = (vhx_diff-vhx*vmod_diff/
     +          vmod)/vmod
              vhinge(1, idx_strip, n) = vhx/vmod
              vhinge_diff(2, idx_strip, n) = (vhy_diff-vhy*vmod_diff/
     +          vmod)/vmod
              vhinge(2, idx_strip, n) = vhy/vmod
              vhinge_diff(3, idx_strip, n) = (vhz_diff-vhz*vmod_diff/
     +          vmod)/vmod
              vhinge(3, idx_strip, n) = vhz/vmod
C
              vrefl(idx_strip, n) = refld(icl, iptl, isurf)
C
              IF (xhd .GE. 0.0) THEN
                phinge(1, idx_strip, n) = rle(1, idx_strip) + xhd
                phinge(2, idx_strip, n) = rle(2, idx_strip)
                phinge(3, idx_strip, n) = rle(3, idx_strip)
              ELSE
                phinge(1, idx_strip, n) = rle(1, idx_strip) - xhd
                phinge(2, idx_strip, n) = rle(2, idx_strip)
                phinge(3, idx_strip, n) = rle(3, idx_strip)
              END IF
            END IF
C Interpolate CD-CL polar defining data from input to strips

          ENDDO
C
          DO idx_coef=1,6
            clcd(idx_coef, idx_strip) = (1.0-fc)*clcdsec(idx_coef, iptl
     +        , isurf) + fc*clcdsec(idx_coef, iptr, isurf)
C If the min drag is zero flag the strip as no-viscous data
          ENDDO
C Set the panel (vortex) geometry data
C Accumulate the strip element indicies and start counting vorticies
          lviscstrp(idx_strip) = clcd(4, idx_strip) .NE. 0.0
C
          IF (idx_strip .EQ. 1) THEN
            ijfrst(idx_strip) = 1
          ELSE
            ijfrst(idx_strip) = ijfrst(idx_strip-1) + nvstrp(idx_strip-1
     +        )
          END IF
          idx_vor = ijfrst(idx_strip)
C Associate the strip with the surface
          nvstrp(idx_strip) = nvc(isurf)
C
C Prepare for cross section interpolation
          lssurf(idx_strip) = isurf
C
          nsl = nasec(iptl, isurf)
C CHORDC = CHORD(idx_strip)      
C Funny story. this original line is now valid now that we interpolate over the strip
          nsr = nasec(iptr, isurf)
C
C
C
C Suggestion from Hal Yougren for non linear sections:
C clafc =  (1.-fc)*clafl + fc*clafr
C loop over vorticies for the strip
          temp1 = chordl*clafl/chord(idx_strip)
          temp2 = chordr*clafr/chord(idx_strip)
          clafc_diff = (1.-fc)*(clafl*chordl_diff+chordl*clafl_diff-
     +      temp1*chord_diff(idx_strip))/chord(idx_strip) + fc*(clafr*
     +      chordr_diff+chordr*clafr_diff-temp2*chord_diff(idx_strip))/
     +      chord(idx_strip)
          clafc = (1.-fc)*temp1 + fc*temp2
C
C Left bound vortex points 
          DO idx_x=1,nvc(isurf)
C Compute the panel left side chord
            idx_node = FLATIDX(idx_x, idx_y, isurf)
            temp0 = mesh_surf(1, idx_node+1) - mesh_surf(1, idx_node)
            temp = mesh_surf(3, idx_node+1) - mesh_surf(3, idx_node)
            arg1_diff = 2*temp0*(mesh_surf_diff(1, idx_node+1)-
     +        mesh_surf_diff(1, idx_node)) + 2*temp*(mesh_surf_diff(3, 
     +        idx_node+1)-mesh_surf_diff(3, idx_node))
            arg1 = temp0*temp0 + temp*temp
            temp0 = SQRT(arg1)
            IF (arg1 .EQ. 0.D0) THEN
              dc1_diff = 0.D0
            ELSE
              dc1_diff = arg1_diff/(2.0*temp0)
            END IF
            dc1 = temp0
C Right bound vortex points 
C
            IF (lmeshflat(isurf)) THEN
C Place vortex at panel quarter chord of the flat mesh
              temp2 = mesh_surf(1, idx_node) - rle1(1, idx_strip)
              temp1 = mesh_surf(3, idx_node) - rle1(3, idx_strip)
              arg10_diff = 2*temp2*(mesh_surf_diff(1, idx_node)-
     +          rle1_diff(1, idx_strip)) + 2*temp1*(mesh_surf_diff(3, 
     +          idx_node)-rle1_diff(3, idx_strip))
              arg10 = temp2*temp2 + temp1*temp1
              temp2 = SQRT(arg10)
              IF (arg10 .EQ. 0.D0) THEN
                dx1_diff = 0.D0
              ELSE
                dx1_diff = arg10_diff/(2.0*temp2)
              END IF
              dx1 = temp2
              rv1_diff(2, idx_vor) = rle1_diff(2, idx_strip)
              rv1(2, idx_vor) = rle1(2, idx_strip)
              rv1_diff(3, idx_vor) = rle1_diff(3, idx_strip)
              rv1(3, idx_vor) = rle1(3, idx_strip)
C Compute the panel left side angle
              rv1_diff(1, idx_vor) = rle1_diff(1, idx_strip) + dx1_diff 
     +          + dc1_diff/4.
              rv1(1, idx_vor) = rle1(1, idx_strip) + dx1 + dc1/4.
C Place vortex at panel quarter chord of the true mesh
              temp0 = mesh_surf(1, idx_node+1) - mesh_surf(1, idx_node)
              temp = mesh_surf(3, idx_node+1) - mesh_surf(3, idx_node)
              a1_diff = temp0*(mesh_surf_diff(3, idx_node+1)-
     +          mesh_surf_diff(3, idx_node))/(temp**2+temp0**2) - temp*(
     +          mesh_surf_diff(1, idx_node+1)-mesh_surf_diff(1, idx_node
     +          ))/(temp**2+temp0**2)
              a1 = ATAN2(temp, temp0)
              rv1msh_diff(2, idx_vor) = mesh_surf_diff(2, idx_node)
              rv1msh(2, idx_vor) = mesh_surf(2, idx_node)
              temp0 = COS(a1)
              rv1msh_diff(1, idx_vor) = mesh_surf_diff(1, idx_node) + 
     +          temp0*dc1_diff/4. - dc1*SIN(a1)*a1_diff/4.
              rv1msh(1, idx_vor) = mesh_surf(1, idx_node) + dc1/4.*temp0
              temp0 = SIN(a1)
              rv1msh_diff(3, idx_vor) = mesh_surf_diff(3, idx_node) + 
     +          temp0*dc1_diff/4. + dc1*COS(a1)*a1_diff/4.
              rv1msh(3, idx_vor) = mesh_surf(3, idx_node) + dc1/4.*temp0
            ELSE
C Compute the panel left side angle
C Place vortex at panel quarter chord
              temp0 = mesh_surf(1, idx_node+1) - mesh_surf(1, idx_node)
              temp = mesh_surf(3, idx_node+1) - mesh_surf(3, idx_node)
              a1_diff = temp0*(mesh_surf_diff(3, idx_node+1)-
     +          mesh_surf_diff(3, idx_node))/(temp**2+temp0**2) - temp*(
     +          mesh_surf_diff(1, idx_node+1)-mesh_surf_diff(1, idx_node
     +          ))/(temp**2+temp0**2)
              a1 = ATAN2(temp, temp0)
              rv1_diff(2, idx_vor) = mesh_surf_diff(2, idx_node)
              rv1(2, idx_vor) = mesh_surf(2, idx_node)
              temp0 = COS(a1)
              rv1_diff(1, idx_vor) = mesh_surf_diff(1, idx_node) + temp0
     +          *dc1_diff/4. - dc1*SIN(a1)*a1_diff/4.
              rv1(1, idx_vor) = mesh_surf(1, idx_node) + dc1/4.*temp0
C Make a copy in the true mesh array for post processing
              temp0 = SIN(a1)
              rv1_diff(3, idx_vor) = mesh_surf_diff(3, idx_node) + temp0
     +          *dc1_diff/4. + dc1*COS(a1)*a1_diff/4.
              rv1(3, idx_vor) = mesh_surf(3, idx_node) + dc1/4.*temp0
              rv1msh_diff(2, idx_vor) = rv1_diff(2, idx_vor)
              rv1msh(2, idx_vor) = rv1(2, idx_vor)
              rv1msh_diff(1, idx_vor) = rv1_diff(1, idx_vor)
              rv1msh(1, idx_vor) = rv1(1, idx_vor)
              rv1msh_diff(3, idx_vor) = rv1_diff(3, idx_vor)
              rv1msh(3, idx_vor) = rv1(3, idx_vor)
            END IF
C Compute the panel right side chord
            idx_node_yp1 = FLATIDX(idx_x, idx_y + 1, isurf)
            temp0 = mesh_surf(1, idx_node_yp1+1) - mesh_surf(1, 
     +        idx_node_yp1)
            temp = mesh_surf(3, idx_node_yp1+1) - mesh_surf(3, 
     +        idx_node_yp1)
            arg1_diff = 2*temp0*(mesh_surf_diff(1, idx_node_yp1+1)-
     +        mesh_surf_diff(1, idx_node_yp1)) + 2*temp*(mesh_surf_diff(
     +        3, idx_node_yp1+1)-mesh_surf_diff(3, idx_node_yp1))
            arg1 = temp0*temp0 + temp*temp
            temp0 = SQRT(arg1)
            IF (arg1 .EQ. 0.D0) THEN
              dc2_diff = 0.D0
            ELSE
              dc2_diff = arg1_diff/(2.0*temp0)
            END IF
            dc2 = temp0
C Mid-point bound vortex points 
C Compute the panel mid-point chord
C Panels themselves can never be curved so just interpolate the chord
C store as the panel chord in common block
C
            IF (lmeshflat(isurf)) THEN
C Place vortex at panel quarter chord of the flat mesh
              temp2 = mesh_surf(1, idx_node_yp1) - rle2(1, idx_strip)
              temp1 = mesh_surf(3, idx_node_yp1) - rle2(3, idx_strip)
              arg10_diff = 2*temp2*(mesh_surf_diff(1, idx_node_yp1)-
     +          rle2_diff(1, idx_strip)) + 2*temp1*(mesh_surf_diff(3, 
     +          idx_node_yp1)-rle2_diff(3, idx_strip))
              arg10 = temp2*temp2 + temp1*temp1
              temp2 = SQRT(arg10)
              IF (arg10 .EQ. 0.D0) THEN
                dx2_diff = 0.D0
              ELSE
                dx2_diff = arg10_diff/(2.0*temp2)
              END IF
              dx2 = temp2
C
              rv2_diff(2, idx_vor) = rle2_diff(2, idx_strip)
              rv2(2, idx_vor) = rle2(2, idx_strip)
              rv2_diff(3, idx_vor) = rle2_diff(3, idx_strip)
              rv2(3, idx_vor) = rle2(3, idx_strip)
C Compute the panel right side angle
              rv2_diff(1, idx_vor) = rle2_diff(1, idx_strip) + dx2_diff 
     +          + dc2_diff/4.
              rv2(1, idx_vor) = rle2(1, idx_strip) + dx2 + dc2/4.
C
C Place vortex at panel quarter chord of the true mesh
              temp0 = mesh_surf(1, idx_node_yp1+1) - mesh_surf(1, 
     +          idx_node_yp1)
              temp = mesh_surf(3, idx_node_yp1+1) - mesh_surf(3, 
     +          idx_node_yp1)
              a2_diff = temp0*(mesh_surf_diff(3, idx_node_yp1+1)-
     +          mesh_surf_diff(3, idx_node_yp1))/(temp**2+temp0**2) - 
     +          temp*(mesh_surf_diff(1, idx_node_yp1+1)-mesh_surf_diff(1
     +          , idx_node_yp1))/(temp**2+temp0**2)
              a2 = ATAN2(temp, temp0)
              rv2msh_diff(2, idx_vor) = mesh_surf_diff(2, idx_node_yp1)
              rv2msh(2, idx_vor) = mesh_surf(2, idx_node_yp1)
              temp0 = COS(a2)
              rv2msh_diff(1, idx_vor) = mesh_surf_diff(1, idx_node_yp1) 
     +          + temp0*dc2_diff/4. - dc2*SIN(a2)*a2_diff/4.
              rv2msh(1, idx_vor) = mesh_surf(1, idx_node_yp1) + dc2/4.*
     +          temp0
              temp0 = SIN(a2)
              rv2msh_diff(3, idx_vor) = mesh_surf_diff(3, idx_node_yp1) 
     +          + temp0*dc2_diff/4. + dc2*COS(a2)*a2_diff/4.
              rv2msh(3, idx_vor) = mesh_surf(3, idx_node_yp1) + dc2/4.*
     +          temp0
            ELSE
C Compute the panel right side angle
C Place vortex at panel quarter chord
              temp0 = mesh_surf(1, idx_node_yp1+1) - mesh_surf(1, 
     +          idx_node_yp1)
              temp = mesh_surf(3, idx_node_yp1+1) - mesh_surf(3, 
     +          idx_node_yp1)
              a2_diff = temp0*(mesh_surf_diff(3, idx_node_yp1+1)-
     +          mesh_surf_diff(3, idx_node_yp1))/(temp**2+temp0**2) - 
     +          temp*(mesh_surf_diff(1, idx_node_yp1+1)-mesh_surf_diff(1
     +          , idx_node_yp1))/(temp**2+temp0**2)
              a2 = ATAN2(temp, temp0)
              rv2_diff(2, idx_vor) = mesh_surf_diff(2, idx_node_yp1)
              rv2(2, idx_vor) = mesh_surf(2, idx_node_yp1)
              temp0 = COS(a2)
              rv2_diff(1, idx_vor) = mesh_surf_diff(1, idx_node_yp1) + 
     +          temp0*dc2_diff/4. - dc2*SIN(a2)*a2_diff/4.
              rv2(1, idx_vor) = mesh_surf(1, idx_node_yp1) + dc2/4.*
     +          temp0
C Make a copy in the true mesh array for post processing
              temp0 = SIN(a2)
              rv2_diff(3, idx_vor) = mesh_surf_diff(3, idx_node_yp1) + 
     +          temp0*dc2_diff/4. + dc2*COS(a2)*a2_diff/4.
              rv2(3, idx_vor) = mesh_surf(3, idx_node_yp1) + dc2/4.*
     +          temp0
C
              rv2msh_diff(2, idx_vor) = rv2_diff(2, idx_vor)
              rv2msh(2, idx_vor) = rv2(2, idx_vor)
              rv2msh_diff(1, idx_vor) = rv2_diff(1, idx_vor)
              rv2msh(1, idx_vor) = rv2(1, idx_vor)
              rv2msh_diff(3, idx_vor) = rv2_diff(3, idx_vor)
              rv2msh(3, idx_vor) = rv2(3, idx_vor)
            END IF
C
C We need to compute the midpoint angle and panel strip chord projection 
C as we need them to compute normals based on the real mesh
            dxv_diff(idx_vor) = (dc1_diff+dc2_diff)/2.
            dxv(idx_vor) = (dc1+dc2)/2.
C project the panel chord onto the strip chord
            arg1_diff = (mesh_surf_diff(3, idx_node_yp1+1)+
     +        mesh_surf_diff(3, idx_node+1))/2. - (mesh_surf_diff(3, 
     +        idx_node_yp1)+mesh_surf_diff(3, idx_node))/2.
            arg1 = (mesh_surf(3, idx_node_yp1+1)+mesh_surf(3, idx_node+1
     +        ))/2. - (mesh_surf(3, idx_node_yp1)+mesh_surf(3, idx_node)
     +        )/2.
            arg2_diff = (mesh_surf_diff(1, idx_node_yp1+1)+
     +        mesh_surf_diff(1, idx_node+1))/2. - (mesh_surf_diff(1, 
     +        idx_node_yp1)+mesh_surf_diff(1, idx_node))/2.
            arg2 = (mesh_surf(1, idx_node_yp1+1)+mesh_surf(1, idx_node+1
     +        ))/2. - (mesh_surf(1, idx_node_yp1)+mesh_surf(1, idx_node)
     +        )/2.
            a3_diff = arg2*arg1_diff/(arg1**2+arg2**2) - arg1*arg2_diff/
     +        (arg1**2+arg2**2)
            a3 = ATAN2(arg1, arg2)
            dxstrpv(idx_vor) = dxv(idx_vor)*COS(a3-gincstrip(idx_strip))
C Panel Control points
C Y- point 
C is just the panel midpoint
C
            IF (lmeshflat(isurf)) THEN
C Place vortex at panel quarter chord of the flat mesh
              temp2 = (mesh_surf(1, idx_node_yp1)+mesh_surf(1, idx_node)
     +          )/2 - rle(1, idx_strip)
              temp1 = (mesh_surf(3, idx_node_yp1)+mesh_surf(3, idx_node)
     +          )/2 - rle(3, idx_strip)
              arg10_diff = 2*temp2*((mesh_surf_diff(1, idx_node_yp1)+
     +          mesh_surf_diff(1, idx_node))/2-rle_diff(1, idx_strip)) +
     +          2*temp1*((mesh_surf_diff(3, idx_node_yp1)+mesh_surf_diff
     +          (3, idx_node))/2-rle_diff(3, idx_strip))
              arg10 = temp2*temp2 + temp1*temp1
              temp2 = SQRT(arg10)
              IF (arg10 .EQ. 0.D0) THEN
                dx3_diff = 0.D0
              ELSE
                dx3_diff = arg10_diff/(2.0*temp2)
              END IF
              dx3 = temp2
              rv_diff(2, idx_vor) = rle_diff(2, idx_strip)
              rv(2, idx_vor) = rle(2, idx_strip)
              rv_diff(3, idx_vor) = rle_diff(3, idx_strip)
              rv(3, idx_vor) = rle(3, idx_strip)
C Place vortex at panel quarter chord of the true mesh
              rv_diff(1, idx_vor) = rle_diff(1, idx_strip) + dx3_diff + 
     +          dxv_diff(idx_vor)/4.
              rv(1, idx_vor) = rle(1, idx_strip) + dx3 + dxv(idx_vor)/4.
C
              rvmsh_diff(2, idx_vor) = (mesh_surf_diff(2, idx_node_yp1)+
     +          mesh_surf_diff(2, idx_node))/2.
              rvmsh(2, idx_vor) = (mesh_surf(2, idx_node_yp1)+mesh_surf(
     +          2, idx_node))/2.
              temp0 = COS(a3)
              temp2 = dxv(idx_vor)/4.
              rvmsh_diff(1, idx_vor) = (mesh_surf_diff(1, idx_node_yp1)+
     +          mesh_surf_diff(1, idx_node))/2. + temp0*dxv_diff(idx_vor
     +          )/4. - temp2*SIN(a3)*a3_diff
              rvmsh(1, idx_vor) = (mesh_surf(1, idx_node_yp1)+mesh_surf(
     +          1, idx_node))/2. + temp2*temp0
              temp0 = SIN(a3)
              temp2 = dxv(idx_vor)/4.
              rvmsh_diff(3, idx_vor) = (mesh_surf_diff(3, idx_node_yp1)+
     +          mesh_surf_diff(3, idx_node))/2. + temp0*dxv_diff(idx_vor
     +          )/4. + temp2*COS(a3)*a3_diff
              rvmsh(3, idx_vor) = (mesh_surf(3, idx_node_yp1)+mesh_surf(
     +          3, idx_node))/2. + temp2*temp0
            ELSE
C  Place vortex at panel quarter chord
              rv_diff(2, idx_vor) = (mesh_surf_diff(2, idx_node_yp1)+
     +          mesh_surf_diff(2, idx_node))/2.
              rv(2, idx_vor) = (mesh_surf(2, idx_node_yp1)+mesh_surf(2, 
     +          idx_node))/2.
              temp0 = COS(a3)
              temp2 = dxv(idx_vor)/4.
              rv_diff(1, idx_vor) = (mesh_surf_diff(1, idx_node_yp1)+
     +          mesh_surf_diff(1, idx_node))/2. + temp0*dxv_diff(idx_vor
     +          )/4. - temp2*SIN(a3)*a3_diff
              rv(1, idx_vor) = (mesh_surf(1, idx_node_yp1)+mesh_surf(1, 
     +          idx_node))/2. + temp2*temp0
C Make a copy in the true mesh array for post processing
              temp0 = SIN(a3)
              temp2 = dxv(idx_vor)/4.
              rv_diff(3, idx_vor) = (mesh_surf_diff(3, idx_node_yp1)+
     +          mesh_surf_diff(3, idx_node))/2. + temp0*dxv_diff(idx_vor
     +          )/4. + temp2*COS(a3)*a3_diff
              rv(3, idx_vor) = (mesh_surf(3, idx_node_yp1)+mesh_surf(3, 
     +          idx_node))/2. + temp2*temp0
C
              rvmsh_diff(2, idx_vor) = rv_diff(2, idx_vor)
              rvmsh(2, idx_vor) = rv(2, idx_vor)
              rvmsh_diff(1, idx_vor) = rv_diff(1, idx_vor)
              rvmsh(1, idx_vor) = rv(1, idx_vor)
              rvmsh_diff(3, idx_vor) = rv_diff(3, idx_vor)
              rvmsh(3, idx_vor) = rv(3, idx_vor)
            END IF
C
C
C Place the control point at the quarter chord + half chord*clafc
C note that clafc is a scaler so is 1. is for 2pi
C use data from vortex mid-point computation
            rc_diff(2, idx_vor) = rv_diff(2, idx_vor)
            rc(2, idx_vor) = rv(2, idx_vor)
C Source points
C Y- point
            IF (lmeshflat(isurf)) THEN
              rc_diff(1, idx_vor) = rv_diff(1, idx_vor) + dxv(idx_vor)*
     +          clafc_diff/2. + clafc*dxv_diff(idx_vor)/2.
              rc(1, idx_vor) = rv(1, idx_vor) + clafc*(dxv(idx_vor)/2.)
              rc_diff(3, idx_vor) = rv_diff(3, idx_vor)
              rc(3, idx_vor) = rv(3, idx_vor)
C
              temp0 = COS(a3)
              temp2 = clafc*dxv(idx_vor)/2.
              rcmsh_diff(1, idx_vor) = rvmsh_diff(1, idx_vor) + temp0*(
     +          dxv(idx_vor)*clafc_diff/2.+clafc*dxv_diff(idx_vor)/2.) -
     +          temp2*SIN(a3)*a3_diff
              rcmsh(1, idx_vor) = rvmsh(1, idx_vor) + temp2*temp0
              temp0 = SIN(a3)
              temp2 = clafc*dxv(idx_vor)/2.
              rcmsh_diff(3, idx_vor) = rvmsh_diff(3, idx_vor) + temp0*(
     +          dxv(idx_vor)*clafc_diff/2.+clafc*dxv_diff(idx_vor)/2.) +
     +          temp2*COS(a3)*a3_diff
              rcmsh(3, idx_vor) = rvmsh(3, idx_vor) + temp2*temp0
              rcmsh_diff(2, idx_vor) = rvmsh_diff(2, idx_vor)
              rcmsh(2, idx_vor) = rvmsh(2, idx_vor)
            ELSE
              temp0 = COS(a3)
              temp2 = clafc*dxv(idx_vor)/2.
              rc_diff(1, idx_vor) = rv_diff(1, idx_vor) + temp0*(dxv(
     +          idx_vor)*clafc_diff/2.+clafc*dxv_diff(idx_vor)/2.) - 
     +          temp2*SIN(a3)*a3_diff
              rc(1, idx_vor) = rv(1, idx_vor) + temp2*temp0
C Make a copy in the true mesh array for post processing
              temp0 = SIN(a3)
              temp2 = clafc*dxv(idx_vor)/2.
              rc_diff(3, idx_vor) = rv_diff(3, idx_vor) + temp0*(dxv(
     +          idx_vor)*clafc_diff/2.+clafc*dxv_diff(idx_vor)/2.) + 
     +          temp2*COS(a3)*a3_diff
              rc(3, idx_vor) = rv(3, idx_vor) + temp2*temp0
C
              rcmsh_diff(1, idx_vor) = rc_diff(1, idx_vor)
              rcmsh(1, idx_vor) = rc(1, idx_vor)
              rcmsh_diff(3, idx_vor) = rc_diff(3, idx_vor)
              rcmsh(3, idx_vor) = rc(3, idx_vor)
              rcmsh_diff(2, idx_vor) = rc_diff(2, idx_vor)
              rcmsh(2, idx_vor) = rc(2, idx_vor)
            END IF
C
C Place the source point at the half chord
C use data from vortex mid-point computation
C add another quarter chord to the quarter chord
            rs_diff(2, idx_vor) = rv_diff(2, idx_vor)
            rs(2, idx_vor) = rv(2, idx_vor)
C Set the camber slopes for the panel
C Camber slope at control point
            IF (lmeshflat(isurf)) THEN
              rs_diff(1, idx_vor) = rv_diff(1, idx_vor) + dxv_diff(
     +          idx_vor)/4.
              rs(1, idx_vor) = rv(1, idx_vor) + dxv(idx_vor)/4.
              rs_diff(3, idx_vor) = rv_diff(3, idx_vor) + dxv_diff(
     +          idx_vor)/4.
              rs(3, idx_vor) = rv(3, idx_vor) + dxv(idx_vor)/4.
            ELSE
              temp0 = COS(a3)
              temp2 = dxv(idx_vor)/4.
              rs_diff(1, idx_vor) = rv_diff(1, idx_vor) + temp0*dxv_diff
     +          (idx_vor)/4. - temp2*SIN(a3)*a3_diff
              rs(1, idx_vor) = rv(1, idx_vor) + temp2*temp0
              temp0 = SIN(a3)
              temp2 = dxv(idx_vor)/4.
              rs_diff(3, idx_vor) = rv_diff(3, idx_vor) + temp0*dxv_diff
     +          (idx_vor)/4. + temp2*COS(a3)*a3_diff
              rs(3, idx_vor) = rv(3, idx_vor) + temp2*temp0
            END IF
C
C
            temp2 = (rc(1, idx_vor)-rle(1, idx_strip))/chord(idx_strip)
            CALL AKIMA_D(xasec(1, iptl, isurf), xasec_diff(1, iptl, 
     +                   isurf), sasec(1, iptl, isurf), sasec_diff(1, 
     +                   iptl, isurf), nsl, (rc(1, idx_vor)-rle(1, 
     +                   idx_strip))/chord(idx_strip), (rc_diff(1, 
     +                   idx_vor)-rle_diff(1, idx_strip)-temp2*
     +                   chord_diff(idx_strip))/chord(idx_strip), slopel
     +                   , slopel_diff, dsdx)
C Alternative for nonlinear sections per Hal Youngren
C SLOPEC(idx_vor) =  (1.-fc)*SLOPEL + fc*SLOPER
C The original line is valid for interpolation over a strip
            temp2 = (rc(1, idx_vor)-rle(1, idx_strip))/chord(idx_strip)
            CALL AKIMA_D(xasec(1, iptr, isurf), xasec_diff(1, iptr, 
     +                   isurf), sasec(1, iptr, isurf), sasec_diff(1, 
     +                   iptr, isurf), nsr, (rc(1, idx_vor)-rle(1, 
     +                   idx_strip))/chord(idx_strip), (rc_diff(1, 
     +                   idx_vor)-rle_diff(1, idx_strip)-temp2*
     +                   chord_diff(idx_strip))/chord(idx_strip), sloper
     +                   , sloper_diff, dsdx)
C
C Camber slope at vortex mid-point
            temp2 = chordl*slopel/chord(idx_strip)
            temp1 = chordr*sloper/chord(idx_strip)
            slopec_diff(idx_vor) = (1.-fc)*(slopel*chordl_diff+chordl*
     +        slopel_diff-temp2*chord_diff(idx_strip))/chord(idx_strip) 
     +        + fc*(sloper*chordr_diff+chordr*sloper_diff-temp1*
     +        chord_diff(idx_strip))/chord(idx_strip)
            slopec(idx_vor) = (1.-fc)*temp2 + fc*temp1
C
            temp2 = (rv(1, idx_vor)-rle(1, idx_strip))/chord(idx_strip)
            CALL AKIMA_D(xasec(1, iptl, isurf), xasec_diff(1, iptl, 
     +                   isurf), sasec(1, iptl, isurf), sasec_diff(1, 
     +                   iptl, isurf), nsl, (rv(1, idx_vor)-rle(1, 
     +                   idx_strip))/chord(idx_strip), (rv_diff(1, 
     +                   idx_vor)-rle_diff(1, idx_strip)-temp2*
     +                   chord_diff(idx_strip))/chord(idx_strip), slopel
     +                   , slopel_diff, dsdx)
C Alternative for nonlinear sections per Hal Youngren
C SLOPEV(idx_vor) =  (1.-fc)*SLOPEL + fc*SLOPER
C The original line is valid for interpolation over a strip
            temp2 = (rv(1, idx_vor)-rle(1, idx_strip))/chord(idx_strip)
            CALL AKIMA_D(xasec(1, iptr, isurf), xasec_diff(1, iptr, 
     +                   isurf), sasec(1, iptr, isurf), sasec_diff(1, 
     +                   iptr, isurf), nsr, (rv(1, idx_vor)-rle(1, 
     +                   idx_strip))/chord(idx_strip), (rv_diff(1, 
     +                   idx_vor)-rle_diff(1, idx_strip)-temp2*
     +                   chord_diff(idx_strip))/chord(idx_strip), sloper
     +                   , sloper_diff, dsdx)
C
C Associate the panel with strip chord and component
            temp2 = chordl*slopel/chord(idx_strip)
            temp1 = chordr*sloper/chord(idx_strip)
            slopev_diff(idx_vor) = (1.-fc)*(slopel*chordl_diff+chordl*
     +        slopel_diff-temp2*chord_diff(idx_strip))/chord(idx_strip) 
     +        + fc*(sloper*chordr_diff+chordr*sloper_diff-temp1*
     +        chord_diff(idx_strip))/chord(idx_strip)
            slopev(idx_vor) = (1.-fc)*temp2 + fc*temp1
C
            chordv_diff(idx_vor) = chord_diff(idx_strip)
            chordv(idx_vor) = chord(idx_strip)
C Enforce no penetration at the control point
            lvcomp(idx_vor) = lncomp(isurf)
C element inherits alpha,beta flag from surface
            lvnc(idx_vor) = .true.
C
C We need to scale the control surface gains by the fraction
C of the element on the control surface
            lvalbe(idx_vor) = lfalbe(isurf)
C
Cscale control gain by factor 0..1, (fraction of element on control surface)
            DO n=1,ncontrol
              temp2 = ((mesh_surf(1, idx_node)+mesh_surf(1, idx_node_yp1
     +          ))/2-rle(1, idx_strip))/chord(idx_strip)
              xpt_diff = ((mesh_surf_diff(1, idx_node)+mesh_surf_diff(1
     +          , idx_node_yp1))/2-rle_diff(1, idx_strip)-temp2*
     +          chord_diff(idx_strip))/chord(idx_strip)
              xpt = temp2
C
              temp2 = chord(idx_strip)/dxv(idx_vor)
              temp1 = xled(n)/chord(idx_strip)
              fracle_diff = temp2*((xled_diff(n)-temp1*chord_diff(
     +          idx_strip))/chord(idx_strip)-xpt_diff) + (temp1-xpt)*(
     +          chord_diff(idx_strip)-temp2*dxv_diff(idx_vor))/dxv(
     +          idx_vor)
              fracle = (temp1-xpt)*temp2
C
              temp2 = chord(idx_strip)/dxv(idx_vor)
              temp1 = xted(n)/chord(idx_strip)
              fracte_diff = temp2*((xted_diff(n)-temp1*chord_diff(
     +          idx_strip))/chord(idx_strip)-xpt_diff) + (temp1-xpt)*(
     +          chord_diff(idx_strip)-temp2*dxv_diff(idx_vor))/dxv(
     +          idx_vor)
              fracte = (temp1-xpt)*temp2
              IF (0.0 .LT. fracle) THEN
                y1_diff = fracle_diff
                y1 = fracle
              ELSE
                y1 = 0.0
                y1_diff = 0.D0
              END IF
              IF (1.0 .GT. y1) THEN
                fracle_diff = y1_diff
                fracle = y1
              ELSE
                fracle = 1.0
                fracle_diff = 0.D0
              END IF
              IF (0.0 .LT. fracte) THEN
                y2_diff = fracte_diff
                y2 = fracte
              ELSE
                y2 = 0.0
                y2_diff = 0.D0
              END IF
              IF (1.0 .GT. y2) THEN
                fracte_diff = y2_diff
                fracte = y2
              ELSE
                fracte = 1.0
                fracte_diff = 0.D0
              END IF
C
              dcontrol_diff(idx_vor, n) = gainda(n)*(fracte_diff-
     +          fracle_diff)
              dcontrol(idx_vor, n) = gainda(n)*(fracte-fracle)
C TE control point used only if surface sheds a wake
            ENDDO
C Use the cross sections to generate the OML
C nodal grid associated with vortex strip (aft-panel nodes)
C NOTE: airfoil in plane of wing, but not rotated perpendicular to dihedral;
C retained in (x,z) plane at this point
C Store the panel LE mid point for the next panel in the strip
C This gets used a lot here 
C We use the original input mesh (true mesh) to compute points for the OML
            lvnc(idx_vor) = lfwake(isurf)
C
C
C   xptxind2 = (mesh_surf(1,idx_node_yp1+1)
C  &           - RLE2(1,idx_strip))/CHORD2(idx_strip) 
C Interpolate cross section on left side
            xptxind1 = ((mesh_surf(1, idx_node+1)+mesh_surf(1, 
     +        idx_node_yp1+1))/2-rle(1, idx_strip))/chord(idx_strip)
C
C
            CALL AKIMA(xlasec(1, iptl, isurf), zlasec(1, iptl, isurf), 
     +                 nsl, xptxind1, zl_l, dsdx)
C Interpolate cross section on right side
            CALL AKIMA(xuasec(1, iptl, isurf), zuasec(1, iptl, isurf), 
     +                 nsl, xptxind1, zu_l, dsdx)
C
            CALL AKIMA(xlasec(1, iptr, isurf), zlasec(1, iptr, isurf), 
     +                 nsr, xptxind1, zl_r, dsdx)
C Compute the left aft node of panel 
C X-point
            CALL AKIMA(xuasec(1, iptr, isurf), zuasec(1, iptr, isurf), 
     +                 nsr, xptxind1, zu_r, dsdx)
C
C
C Y-point
            xyn1(1, idx_vor) = rle1(1, idx_strip) + xptxind1*chord1(
     +        idx_strip)
C
C Interpolate z from sections to left aft node of panel
            xyn1(2, idx_vor) = rle1(2, idx_strip)
C
            zl = (1.-f1)*zl_l + f1*zl_r
C Store left aft z-point
            zu = (1.-f1)*zu_l + f1*zu_r
C
            zlon1(idx_vor) = rle1(3, idx_strip) + zl*chord1(idx_strip)
C Compute the right aft node of panel 
C X-point
            zupn1(idx_vor) = rle1(3, idx_strip) + zu*chord1(idx_strip)
C
C Y-point
            xyn2(1, idx_vor) = rle2(1, idx_strip) + xptxind1*chord2(
     +        idx_strip)
C
C Interpolate z from sections to right aft node of panel
            xyn2(2, idx_vor) = rle2(2, idx_strip)
            zl = (1.-f2)*zl_l + f2*zl_r
C Store right aft z-point
            zu = (1.-f2)*zu_l + f2*zu_r
C
            zlon2(idx_vor) = rle2(3, idx_strip) + zl*chord2(idx_strip)
            zupn2(idx_vor) = rle2(3, idx_strip) + zu*chord2(idx_strip)
C
            idx_vor = idx_vor + 1
C End vortex loop
          ENDDO
          idx_strip = idx_strip + 1
C End strip loop
C Compute the wetted area and cave from the true mesh
        ENDDO
C
        sum = 0.0
        wtot = 0.0
        DO jj=1,nj(isurf)
          j = jfrst(isurf) + jj - 1
          astrp = wstrip(j)*chord(j)
          sum = sum + astrp
          wtot = wtot + wstrip(j)
        ENDDO
        ssurf(isurf) = sum
C add number of strips to the global count
C
        IF (wtot .EQ. 0.0) THEN
          cavesurf(isurf) = 0.0
        ELSE
          cavesurf(isurf) = sum/wtot
        END IF
C add number of of votrices to the global count
        nstrip = nstrip + nj(isurf)
        nvor = nvor + nk(isurf)*nj(isurf)
      END IF
      END

C  Differentiation of sdupl in forward (tangent) mode (with options i4 dr8 r8):
C   variations   of useful results: rv1msh rv2msh rvmsh rcmsh rle
C                chord rle1 chord1 rle2 chord2 wstrip ainc ainc_g
C                rv1 rv2 rv rc dxv chordv slopev slopec dcontrol
C                vhinge
C   with respect to varying inputs: rv1msh rv2msh rvmsh rcmsh rle
C                chord rle1 chord1 rle2 chord2 wstrip ainc ainc_g
C                rv1 rv2 rv rc dxv chordv slopev slopec dcontrol
C                vhinge
C
      SUBROUTINE SDUPL_D(nn, ypt, msg)
      INCLUDE 'AVL.INC'
      INCLUDE 'AVL_ad_seeds.inc'
      CHARACTER*(*) msg
      INTEGER idx_vor
      INTEGER nni
      INTEGER klen
      INTRINSIC LEN
      INTEGER k
      INTEGER isec
      INTEGER idup
      INTEGER iorg
      REAL yoff
      INTEGER idx_strip
      INTEGER ivs
      INTEGER jji
      INTEGER jj
      INTEGER n
      INTEGER l
      INTEGER ivc
      INTEGER iii
      INTEGER ii
      REAL rsgn
      INTEGER nn
      REAL ypt
C
C     
      nni = nn + 1
      IF (nni .GT. nfmax) THEN
        WRITE(*, *) 'SDUPL: Surface array overflow. Increase NFMAX', 
     +        ' currently ', nfmax
        STOP
      ELSE
C
        klen = LEN(stitle(nn))
        DO k=klen,1,-1
          IF (stitle(nn)(k:k) .NE. ' ') EXIT
        ENDDO
        stitle(nni) = stitle(nn)(1:k)//' ('//msg//')'
        IF (lverbose) THEN
          WRITE(*, *) ' '
          WRITE(*, *) '  Building duplicate image-surface: ', stitle(nni
     +          )
        END IF
C
C---- duplicate surface is assumed to be the same logical component surface
        lncomp(nni) = lncomp(nn)
C
C---- same various logical flags
        lfwake(nni) = lfwake(nn)
        lfalbe(nni) = lfalbe(nn)
        lfload(nni) = lfload(nn)
        lrange(nni) = lrange(nn)
        lsurfspacing(nni) = lsurfspacing(nn)
        lmeshflat(nni) = lmeshflat(nn)
C IFRST(NNI) = NVOR   + 1
        lsurfmsh(nni) = lsurfmsh(nn)
C
C---- accumulate stuff for new image surface 
        ifrst(nni) = ifrst(nni-1) + nk(nni-1)*nj(nni-1)
C JFRST(NNI) = NSTRIP + 1
        jfrst(nni) = jfrst(nni-1) + nj(nni-1)
        nj(nni) = nj(nn)
        nk(nni) = nk(nn)
C
        nvc(nni) = nk(nni)
        nvs(nni) = nj(nni)
C
        ssurf(nni) = ssurf(nn)
        cavesurf(nni) = cavesurf(nn)
C--- Note hinge axis is flipped to reverse the Y component of the hinge
C    vector.   This means that deflections need to be reversed for image
C    surfaces.
C
C--- Image flag reversed (set to -IMAGS) for imaged surfaces
        imags(nni) = -imags(nn)
C
Cc#ifdef USE_CPOML
        icntfrst(nni) = icntfrst(nn) + ncntsec(nn)
        ncntsec(nni) = ncntsec(nn)
        DO isec=1,ncntsec(nni)
          idup = icntfrst(nni) + (isec-1)
          iorg = icntfrst(nn) + (isec-1)
          icntsec(idup) = icntsec(iorg)
        ENDDO
Cc#endif
C
        yoff = 2.0*ypt
C
C--- Create image strips, to maintain the same sense of positive GAMMA
C    these have the 1 and 2 strip edges reversed (i.e. root is edge 2, 
C    not edge 1 as for a strip with IMAGS=1
        idx_strip = jfrst(nni)
C   NSTRIP = NSTRIP + 1
        DO ivs=1,nvs(nni)
          IF (idx_strip .GT. nsmax) THEN
            GOTO 100
          ELSE
C
            jji = jfrst(nni) + ivs - 1
            jj = jfrst(nn) + ivs - 1
            rle1_diff(1, jji) = rle2_diff(1, jj)
            rle1(1, jji) = rle2(1, jj)
            rle1_diff(2, jji) = -rle2_diff(2, jj)
            rle1(2, jji) = -rle2(2, jj) + yoff
            rle1_diff(3, jji) = rle2_diff(3, jj)
            rle1(3, jji) = rle2(3, jj)
            chord1_diff(jji) = chord2_diff(jj)
            chord1(jji) = chord2(jj)
            rle2_diff(1, jji) = rle1_diff(1, jj)
            rle2(1, jji) = rle1(1, jj)
            rle2_diff(2, jji) = -rle1_diff(2, jj)
            rle2(2, jji) = -rle1(2, jj) + yoff
            rle2_diff(3, jji) = rle1_diff(3, jj)
            rle2(3, jji) = rle1(3, jj)
            chord2_diff(jji) = chord1_diff(jj)
            chord2(jji) = chord1(jj)
            rle_diff(1, jji) = rle_diff(1, jj)
            rle(1, jji) = rle(1, jj)
            rle_diff(2, jji) = -rle_diff(2, jj)
            rle(2, jji) = -rle(2, jj) + yoff
            rle_diff(3, jji) = rle_diff(3, jj)
            rle(3, jji) = rle(3, jj)
            chord_diff(jji) = chord_diff(jj)
            chord(jji) = chord(jj)
            gincstrip(jji) = gincstrip(jj)
            wstrip_diff(jji) = wstrip_diff(jj)
            wstrip(jji) = wstrip(jj)
            tanle(jji) = -tanle(jj)
            ainc_diff(jji) = ainc_diff(jj)
            ainc(jji) = ainc(jj)
C
Cc#ifdef USE_CPOML
            ainc1(jji) = ainc2(jj)
            ainc2(jji) = ainc1(jj)
C
Cc#endif
            lssurf(idx_strip) = nni
C
            DO n=1,ndesign
              ainc_g_diff(jji, n) = ainc_g_diff(jj, n)
              ainc_g(jji, n) = ainc_g(jj, n)
            ENDDO
C
            DO n=1,ncontrol
              vrefl(jji, n) = vrefl(jj, n)
C
              vhinge_diff(1, jji, n) = vhinge_diff(1, jj, n)
              vhinge(1, jji, n) = vhinge(1, jj, n)
              vhinge_diff(2, jji, n) = -vhinge_diff(2, jj, n)
              vhinge(2, jji, n) = -vhinge(2, jj, n)
              vhinge_diff(3, jji, n) = vhinge_diff(3, jj, n)
              vhinge(3, jji, n) = vhinge(3, jj, n)
C
              phinge(1, jji, n) = phinge(1, jj, n)
              phinge(2, jji, n) = -phinge(2, jj, n) + yoff
              phinge(3, jji, n) = phinge(3, jj, n)
C   IJFRST(JJI)  = NVOR + 1
C   IJFRST(JJI) = IJFRST(NSTRIP - 1) + NVC(NNI)
            ENDDO
C
C--- The defined section for image strip is flagged with (-)
            ijfrst(jji) = ijfrst(jji-1) + nvstrp(jji-1)
C
            nvstrp(jji) = nvc(nni)
            DO l=1,6
              clcd(l, jji) = clcd(l, jj)
            ENDDO
            lviscstrp(jji) = lviscstrp(jj)
C
            idx_vor = ijfrst(jji)
C
C     NVOR = NVOR + 1
            DO ivc=1,nvc(nni)
              IF (idx_vor .GT. nvmax) THEN
                GOTO 110
              ELSE
C
                iii = ijfrst(jji) + ivc - 1
                ii = ijfrst(jj) + ivc - 1
                rv1_diff(1, iii) = rv2_diff(1, ii)
                rv1(1, iii) = rv2(1, ii)
                rv1_diff(2, iii) = -rv2_diff(2, ii)
                rv1(2, iii) = -rv2(2, ii) + yoff
                rv1_diff(3, iii) = rv2_diff(3, ii)
                rv1(3, iii) = rv2(3, ii)
                rv2_diff(1, iii) = rv1_diff(1, ii)
                rv2(1, iii) = rv1(1, ii)
                rv2_diff(2, iii) = -rv1_diff(2, ii)
                rv2(2, iii) = -rv1(2, ii) + yoff
                rv2_diff(3, iii) = rv1_diff(3, ii)
                rv2(3, iii) = rv1(3, ii)
                rv_diff(1, iii) = rv_diff(1, ii)
                rv(1, iii) = rv(1, ii)
                rv_diff(2, iii) = -rv_diff(2, ii)
                rv(2, iii) = -rv(2, ii) + yoff
                rv_diff(3, iii) = rv_diff(3, ii)
                rv(3, iii) = rv(3, ii)
                rc_diff(1, iii) = rc_diff(1, ii)
                rc(1, iii) = rc(1, ii)
                rc_diff(2, iii) = -rc_diff(2, ii)
                rc(2, iii) = -rc(2, ii) + yoff
                rc_diff(3, iii) = rc_diff(3, ii)
                rc(3, iii) = rc(3, ii)
                slopec_diff(iii) = slopec_diff(ii)
                slopec(iii) = slopec(ii)
                slopev_diff(iii) = slopev_diff(ii)
                slopev(iii) = slopev(ii)
                dxv_diff(iii) = dxv_diff(ii)
                dxv(iii) = dxv(ii)
                dxstrpv(iii) = dxstrpv(ii)
                chordv_diff(iii) = chordv_diff(ii)
                chordv(iii) = chordv(ii)
                lvcomp(iii) = lncomp(nni)
                lvalbe(iii) = lvalbe(ii)
C Duplicate mesh data if we are using a mesh
                lvnc(iii) = lvnc(ii)
                IF (lsurfmsh(nn)) THEN
                  rv1msh_diff(1, iii) = rv2msh_diff(1, ii)
                  rv1msh(1, iii) = rv2msh(1, ii)
                  rv1msh_diff(2, iii) = -rv2msh_diff(2, ii)
                  rv1msh(2, iii) = -rv2msh(2, ii) + yoff
                  rv1msh_diff(3, iii) = rv2msh_diff(3, ii)
                  rv1msh(3, iii) = rv2msh(3, ii)
                  rv2msh_diff(1, iii) = rv1msh_diff(1, ii)
                  rv2msh(1, iii) = rv1msh(1, ii)
                  rv2msh_diff(2, iii) = -rv1msh_diff(2, ii)
                  rv2msh(2, iii) = -rv1msh(2, ii) + yoff
                  rv2msh_diff(3, iii) = rv1msh_diff(3, ii)
                  rv2msh(3, iii) = rv1msh(3, ii)
                  rvmsh_diff(1, iii) = rvmsh_diff(1, ii)
                  rvmsh(1, iii) = rvmsh(1, ii)
                  rvmsh_diff(2, iii) = -rvmsh_diff(2, ii)
                  rvmsh(2, iii) = -rvmsh(2, ii) + yoff
                  rvmsh_diff(3, iii) = rvmsh_diff(3, ii)
                  rvmsh(3, iii) = rvmsh(3, ii)
                  rcmsh_diff(1, iii) = rcmsh_diff(1, ii)
                  rcmsh(1, iii) = rcmsh(1, ii)
                  rcmsh_diff(2, iii) = -rcmsh_diff(2, ii)
                  rcmsh(2, iii) = -rcmsh(2, ii) + yoff
                  rcmsh_diff(3, iii) = rcmsh_diff(3, ii)
                  rcmsh(3, iii) = rcmsh(3, ii)
                END IF
C
                DO n=1,ncontrol
Ccc         RSGN = SIGN( 1.0 , VREFL(JJ,N) )
                  rsgn = vrefl(jj, n)
                  dcontrol_diff(iii, n) = -(rsgn*dcontrol_diff(ii, n))
                  dcontrol(iii, n) = -(dcontrol(ii, n)*rsgn)
                ENDDO
C          
Cc#ifdef USE_CPOML
C...      nodal grid associated with vortex strip
                xyn1(1, iii) = xyn2(1, ii)
                xyn1(2, iii) = -xyn2(2, ii) + yoff
                xyn2(1, iii) = xyn1(1, ii)
                xyn2(2, iii) = -xyn1(2, ii) + yoff
C
                zlon1(iii) = zlon2(ii)
                zupn1(iii) = zupn2(ii)
                zlon2(iii) = zlon1(ii)
                zupn2(iii) = zupn1(ii)
Cc#endif
                idx_vor = idx_vor + 1
              END IF
            ENDDO
C
            idx_strip = idx_strip + 1
          END IF
        ENDDO
C
C
C
        nstrip = nstrip + nj(nni)
        nvor = nvor + nk(nni)*nj(nni)
C
        RETURN
 100    WRITE(*, *) 'SDUPL: Strip array overflow. Increase NSMAX', 
     +        ' currently ', nsmax
        STOP
 110    WRITE(*, *) 'SDUPL: Vortex array overflow. Increase NVMAX', 
     +        ' currently ', nvmax
        STOP
      END IF
      END

C  Differentiation of encalc in forward (tangent) mode (with options i4 dr8 r8):
C   variations   of useful results: ess ensy ensz xsref ysref zsref
C                enc env enc_d
C   with respect to varying inputs: rv1msh rv2msh rvmsh rcmsh ainc
C                ainc_g rv1 rv2 rv slopev slopec dcontrol vhinge
C BDUPL
C
C
C
C
C Also checks if surface has been assigned a point cloud mesh
C and uses the real mesh to compute normals if it is
      SUBROUTINE ENCALC_D()
      INCLUDE 'AVL.INC'
      INCLUDE 'AVL_ad_seeds.inc'
C
      REAL ep(3), eq(3), es(3), eb(3), ec(3), ecxb(3)
      REAL ep_diff(3), eq_diff(3), es_diff(3), eb_diff(3), ec_diff(3), 
     +     ecxb_diff(3)
      REAL ec_g(3, ndmax), ecxb_g(3)
      REAL(kind=avl_real) dchstrip, dxt, dyt, dzt, ec_msh(3)
      REAL(kind=avl_real) dxt_diff, dyt_diff, dzt_diff, ec_msh_diff(3)
      INTEGER j
      INTEGER i
      REAL dxle
      REAL dxle_diff
      REAL dyle
      REAL dyle_diff
      REAL dzle
      REAL dzle_diff
      REAL axle
      REAL axle_diff
      REAL ayle
      REAL ayle_diff
      REAL azle
      REAL azle_diff
      REAL dxte
      REAL dxte_diff
      REAL dyte
      REAL dyte_diff
      REAL dzte
      REAL dzte_diff
      REAL axte
      REAL axte_diff
      REAL ayte
      REAL ayte_diff
      REAL azte
      REAL azte_diff
      INTRINSIC SQRT
      INTEGER nv
      INTEGER ii
      INTEGER n
      REAL dxb
      REAL dxb_diff
      REAL dyb
      REAL dyb_diff
      REAL dzb
      REAL dzb_diff
      REAL emag
      REAL emag_diff
      REAL ang
      REAL ang_diff
      INTRINSIC ATAN
      REAL sinc
      REAL sinc_diff
      INTRINSIC SIN
      REAL cosc
      REAL cosc_diff
      INTRINSIC COS
      REAL emag_g
      REAL ang_ddc
      REAL ang_ddc_diff
      REAL cosd
      REAL sind
      REAL endot
      REAL endot_diff
      REAL DOT
      REAL DOT_D
      REAL(kind=avl_real) arg1
      REAL(kind=avl_real) arg1_diff
      REAL(kind=avl_real) result1
      REAL(kind=avl_real) result1_diff
      REAL arg10
      REAL arg10_diff
      REAL(kind=avl_real) temp
      REAL temp0
      REAL(kind=avl_real) temp1
      REAL(kind=avl_real) temp2
      INTEGER ii1
      INTEGER ii3
      INTEGER ii2
      DO ii1=1,NSTRIP
        DO ii2=1,3
          ess_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,NSTRIP
        ensy_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,NSTRIP
        ensz_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,NSTRIP
        xsref_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,NSTRIP
        ysref_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,NSTRIP
        zsref_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nvor
        DO ii2=1,3
          enc_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,nvor
        DO ii2=1,3
          env_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,ndmax
        DO ii2=1,nvor
          DO ii3=1,3
            enc_d_diff(ii3, ii2, ii1) = 0.D0
          ENDDO
        ENDDO
      ENDDO
      DO ii1=1,3
        eb_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        ec_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        ep_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        eq_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        es_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        ecxb_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        ec_msh_diff(ii1) = 0.D0
      ENDDO
C
C...Calculate the normal vector at control points and bound vortex midpoints
C
C Since we cannot seperate the encalc routine for direct mesh assignment we have to make it a branch here
      DO j=1,nstrip
C
        IF (lsurfmsh(lssurf(j))) THEN
C Calculate normal vector for the strip (normal to X axis)
C we can't just interpolate this anymore given that 
C the strip is no longer necessarily linear chordwise
C We want the spanwise unit vector for the strip at the 
C chordwise location specified by SAXFR (usually set to 0.25)
C Loop over all panels in the strip until we find the one that contains
C the SAXFR position in it's projected chord. Since the panels themselves are still linear
C we can just use the bound vortex unit vector of that panel as 
C the spanwise unit vector of the strip at SAXFR
C SAB: This is slow, find a better way to do this
C
C
C
          dchstrip = 0.0
      searchsaxfr:DO i=ijfrst(j),ijfrst(j)+(nvstrp(j)-1)
            dchstrip = dchstrip + dxstrpv(i)
            IF (dchstrip .GE. chord(j)*saxfr) EXIT
          ENDDO searchsaxfr
C
C
          dxt_diff = rv2msh_diff(1, i) - rv1msh_diff(1, i)
          dxt = rv2msh(1, i) - rv1msh(1, i)
          dyt_diff = rv2msh_diff(2, i) - rv1msh_diff(2, i)
          dyt = rv2msh(2, i) - rv1msh(2, i)
          dzt_diff = rv2msh_diff(3, i) - rv1msh_diff(3, i)
          dzt = rv2msh(3, i) - rv1msh(3, i)
          xsref_diff(j) = rvmsh_diff(1, i)
          xsref(j) = rvmsh(1, i)
          ysref_diff(j) = rvmsh_diff(2, i)
          ysref(j) = rvmsh(2, i)
          zsref_diff(j) = rvmsh_diff(3, i)
          zsref(j) = rvmsh(3, i)
C
        ELSE
C original encalc routine for standard AVL geometry
C
C...Calculate normal vector for the strip (normal to X axis)
          i = ijfrst(j)
          dxle_diff = rv2_diff(1, i) - rv1_diff(1, i)
          dxle = rv2(1, i) - rv1(1, i)
          dyle_diff = rv2_diff(2, i) - rv1_diff(2, i)
          dyle = rv2(2, i) - rv1(2, i)
          dzle_diff = rv2_diff(3, i) - rv1_diff(3, i)
          dzle = rv2(3, i) - rv1(3, i)
C       AXLE = (RV2(1,I)+RV1(1,I))*0.5
C       AYLE = (RV2(2,I)+RV1(2,I))*0.5
C       AZLE = (RV2(3,I)+RV1(3,I))*0.5
          axle_diff = rv_diff(1, i)
          axle = rv(1, i)
          ayle_diff = rv_diff(2, i)
          ayle = rv(2, i)
          azle_diff = rv_diff(3, i)
          azle = rv(3, i)
C
          i = ijfrst(j) + (nvstrp(j)-1)
          dxte_diff = rv2_diff(1, i) - rv1_diff(1, i)
          dxte = rv2(1, i) - rv1(1, i)
          dyte_diff = rv2_diff(2, i) - rv1_diff(2, i)
          dyte = rv2(2, i) - rv1(2, i)
          dzte_diff = rv2_diff(3, i) - rv1_diff(3, i)
          dzte = rv2(3, i) - rv1(3, i)
C       AXTE = (RV2(1,I)+RV1(1,I))*0.5
C       AYTE = (RV2(2,I)+RV1(2,I))*0.5
C       AZTE = (RV2(3,I)+RV1(3,I))*0.5
          axte_diff = rv_diff(1, i)
          axte = rv(1, i)
          ayte_diff = rv_diff(2, i)
          ayte = rv(2, i)
          azte_diff = rv_diff(3, i)
          azte = rv(3, i)
C
          dxt_diff = (1.0-saxfr)*dxle_diff + saxfr*dxte_diff
          dxt = (1.0-saxfr)*dxle + saxfr*dxte
          dyt_diff = (1.0-saxfr)*dyle_diff + saxfr*dyte_diff
          dyt = (1.0-saxfr)*dyle + saxfr*dyte
          dzt_diff = (1.0-saxfr)*dzle_diff + saxfr*dzte_diff
          dzt = (1.0-saxfr)*dzle + saxfr*dzte
C
          xsref_diff(j) = (1.0-saxfr)*axle_diff + saxfr*axte_diff
          xsref(j) = (1.0-saxfr)*axle + saxfr*axte
          ysref_diff(j) = (1.0-saxfr)*ayle_diff + saxfr*ayte_diff
          ysref(j) = (1.0-saxfr)*ayle + saxfr*ayte
          zsref_diff(j) = (1.0-saxfr)*azle_diff + saxfr*azte_diff
          zsref(j) = (1.0-saxfr)*azle + saxfr*azte
        END IF
C
C
        arg1_diff = 2*dxt*dxt_diff + 2*dyt*dyt_diff + 2*dzt*dzt_diff
        arg1 = dxt*dxt + dyt*dyt + dzt*dzt
        temp = SQRT(arg1)
        IF (arg1 .EQ. 0.D0) THEN
          result1_diff = 0.D0
        ELSE
          result1_diff = arg1_diff/(2.0*temp)
        END IF
        result1 = temp
        ess_diff(1, j) = (dxt_diff-dxt*result1_diff/result1)/result1
        ess(1, j) = dxt/result1
        arg1_diff = 2*dxt*dxt_diff + 2*dyt*dyt_diff + 2*dzt*dzt_diff
        arg1 = dxt*dxt + dyt*dyt + dzt*dzt
        temp = SQRT(arg1)
        IF (arg1 .EQ. 0.D0) THEN
          result1_diff = 0.D0
        ELSE
          result1_diff = arg1_diff/(2.0*temp)
        END IF
        result1 = temp
        ess_diff(2, j) = (dyt_diff-dyt*result1_diff/result1)/result1
        ess(2, j) = dyt/result1
C Treffz plane normals
        arg1_diff = 2*dxt*dxt_diff + 2*dyt*dyt_diff + 2*dzt*dzt_diff
        arg1 = dxt*dxt + dyt*dyt + dzt*dzt
        temp = SQRT(arg1)
        IF (arg1 .EQ. 0.D0) THEN
          result1_diff = 0.D0
        ELSE
          result1_diff = arg1_diff/(2.0*temp)
        END IF
        result1 = temp
        ess_diff(3, j) = (dzt_diff-dzt*result1_diff/result1)/result1
        ess(3, j) = dzt/result1
C
        arg1_diff = 2*dyt*dyt_diff + 2*dzt*dzt_diff
        arg1 = dyt*dyt + dzt*dzt
        temp = SQRT(arg1)
        IF (arg1 .EQ. 0.D0) THEN
          result1_diff = 0.D0
        ELSE
          result1_diff = arg1_diff/(2.0*temp)
        END IF
        result1 = temp
        ensy_diff(j) = -((dzt_diff-dzt*result1_diff/result1)/result1)
        ensy(j) = -(dzt/result1)
        arg1_diff = 2*dyt*dyt_diff + 2*dzt*dzt_diff
        arg1 = dyt*dyt + dzt*dzt
        temp = SQRT(arg1)
        IF (arg1 .EQ. 0.D0) THEN
          result1_diff = 0.D0
        ELSE
          result1_diff = arg1_diff/(2.0*temp)
        END IF
        result1 = temp
        ensz_diff(j) = (dyt_diff-dyt*result1_diff/result1)/result1
        ensz(j) = dyt/result1
C
        es_diff(1) = 0.D0
        es(1) = 0.
        es_diff(2) = ensy_diff(j)
        es(2) = ensy(j)
        es_diff(3) = ensz_diff(j)
        es(3) = ensz(j)
C
        lstripoff(j) = .false.
C
        nv = nvstrp(j)
        DO ii=1,nv
C
          i = ijfrst(j) + (ii-1)
C
          DO n=1,ncontrol
            env_d(1, i, n) = 0.
            env_d(2, i, n) = 0.
            env_d(3, i, n) = 0.
            enc_d_diff(1, i, n) = 0.D0
            enc_d(1, i, n) = 0.
            enc_d_diff(2, i, n) = 0.D0
            enc_d(2, i, n) = 0.
            enc_d_diff(3, i, n) = 0.D0
            enc_d(3, i, n) = 0.
          ENDDO
C
          DO n=1,ndesign
            env_g(1, i, n) = 0.
            env_g(2, i, n) = 0.
            env_g(3, i, n) = 0.
            enc_g(1, i, n) = 0.
            enc_g(2, i, n) = 0.
            enc_g(3, i, n) = 0.
          ENDDO
C
          IF (lsurfmsh(lssurf(j))) THEN
C Define unit vector along bound leg
C right h.v. pt - left h.v. pt 
            dxb_diff = rv2msh_diff(1, i) - rv1msh_diff(1, i)
            dxb = rv2msh(1, i) - rv1msh(1, i)
            dyb_diff = rv2msh_diff(2, i) - rv1msh_diff(2, i)
            dyb = rv2msh(2, i) - rv1msh(2, i)
            dzb_diff = rv2msh_diff(3, i) - rv1msh_diff(3, i)
            dzb = rv2msh(3, i) - rv1msh(3, i)
          ELSE
C
C...Define unit vector along bound leg
C right h.v. pt - left h.v. pt 
            dxb_diff = rv2_diff(1, i) - rv1_diff(1, i)
            dxb = rv2(1, i) - rv1(1, i)
            dyb_diff = rv2_diff(2, i) - rv1_diff(2, i)
            dyb = rv2(2, i) - rv1(2, i)
            dzb_diff = rv2_diff(3, i) - rv1_diff(3, i)
            dzb = rv2(3, i) - rv1(3, i)
          END IF
          arg10_diff = 2*dxb*dxb_diff + 2*dyb*dyb_diff + 2*dzb*dzb_diff
          arg10 = dxb**2 + dyb**2 + dzb**2
          temp0 = SQRT(arg10)
          IF (arg10 .EQ. 0.D0) THEN
            emag_diff = 0.D0
          ELSE
            emag_diff = arg10_diff/(2.0*temp0)
          END IF
          emag = temp0
          eb_diff(1) = (dxb_diff-dxb*emag_diff/emag)/emag
          eb(1) = dxb/emag
          eb_diff(2) = (dyb_diff-dyb*emag_diff/emag)/emag
          eb(2) = dyb/emag
C First start by combining the contributions to the panel 
C incidence from AVL incidence and camberline slope variables
C these are not actual geometric transformations of the mesh
C but rather further modifications to the chordwise vector that 
C will get used to compute normals
          eb_diff(3) = (dzb_diff-dzb*emag_diff/emag)/emag
          eb(3) = dzb/emag
C
C...Define direction of normal vector at control point 
C   The YZ projection of the normal vector matches the camber slope
C   + section local incidence in the YZ defining plane for the section
          ang_diff = ainc_diff(j) - slopec_diff(i)/(1.0+slopec(i)**2)
          ang = ainc(j) - ATAN(slopec(i))
Cc          IF(LDES) THEN
C--------- add design-variable contribution to angle
          DO n=1,ndesign
            ang_diff = ang_diff + deldes(n)*ainc_g_diff(j, n)
            ang = ang + ainc_g(j, n)*deldes(n)
          ENDDO
Cc          ENDIF
C
          sinc_diff = COS(ang)*ang_diff
          sinc = SIN(ang)
          cosc_diff = -(SIN(ang)*ang_diff)
          cosc = COS(ang)
C
          IF (lsurfmsh(lssurf(j))) THEN
C direct mesh assignemnt branch
C now we compute the chordwise panel vector
C note that panel`s chordwise vector has contributions
C from both the geometry itself and the incidence modification
C from the AVL AINC and camber slope variables
C Get the geometric chordwise vector using RVMSH and RCMSH which should
C be located in the same plane given that each individual panel is a 
C plane
C
C
            temp = rcmsh(1, i) - rvmsh(1, i)
            temp1 = rcmsh(2, i) - rvmsh(2, i)
            temp2 = rcmsh(3, i) - rvmsh(3, i)
            arg1_diff = 2*temp*(rcmsh_diff(1, i)-rvmsh_diff(1, i)) + 2*
     +        temp1*(rcmsh_diff(2, i)-rvmsh_diff(2, i)) + 2*temp2*(
     +        rcmsh_diff(3, i)-rvmsh_diff(3, i))
            arg1 = temp*temp + temp1*temp1 + temp2*temp2
            temp2 = SQRT(arg1)
            IF (arg1 .EQ. 0.D0) THEN
              emag_diff = 0.D0
            ELSE
              emag_diff = arg1_diff/(2.0*temp2)
            END IF
            emag = temp2
            temp2 = (rcmsh(1, i)-rvmsh(1, i))/emag
            ec_msh_diff(1) = (rcmsh_diff(1, i)-rvmsh_diff(1, i)-temp2*
     +        emag_diff)/emag
            ec_msh(1) = temp2
            temp2 = (rcmsh(2, i)-rvmsh(2, i))/emag
            ec_msh_diff(2) = (rcmsh_diff(2, i)-rvmsh_diff(2, i)-temp2*
     +        emag_diff)/emag
            ec_msh(2) = temp2
C Now we have to rotate this vector by the incidence contribution from AINC and CAMBER
C However, this rotation needs to be done about the local y-axis of the wing 
C Earlier we computed ES the normal vector of the strip projected to the Trefftz plane
C The axis we need to rotate about is the one purpendicular to this ES.
C As a result all panel normals in a given strip will be rotated about the same axis defined by the that strip
C The components of the rotation axis are obtained from ES as follows
C rot_axis(1) = 0
C rot_axis(2) = -ES(3)
C rot_axis(3) = ES(2)
C We can then multiply ec_msh by the rotation matrix for a rotation about an arbitrary axis
C see https://pubs.aip.org/aapt/ajp/article/44/1/63/1050167/Formalism-for-the-rotation-matrix-of-rotations
C Note that standard AVL also does this exact same thing but since they always rotate the vector [1,0,0]
C the result collapses into the ridiculously simple expression for EC that you see in the other branch
            temp2 = (rcmsh(3, i)-rvmsh(3, i))/emag
            ec_msh_diff(3) = (rcmsh_diff(3, i)-rvmsh_diff(3, i)-temp2*
     +        emag_diff)/emag
            ec_msh(3) = temp2
C
C
            ec_diff(1) = ec_msh(1)*cosc_diff + cosc*ec_msh_diff(1) + 
     +        ec_msh(2)*(sinc*es_diff(2)+es(2)*sinc_diff) + es(2)*sinc*
     +        ec_msh_diff(2) + ec_msh(3)*(sinc*es_diff(3)+es(3)*
     +        sinc_diff) + es(3)*sinc*ec_msh_diff(3)
            ec(1) = cosc*ec_msh(1) + es(2)*sinc*ec_msh(2) + es(3)*sinc*
     +        ec_msh(3)
            temp0 = es(3)*es(3)*(-cosc+1) + cosc
            ec_diff(2) = ec_msh(2)*((1-cosc)*2*es(3)*es_diff(3)-(es(3)**
     +        2-1.0)*cosc_diff) + temp0*ec_msh_diff(2) - sinc*es_diff(2)
     +        - es(2)*sinc_diff - (1-cosc)*ec_msh(3)*(es(3)*es_diff(2)+
     +        es(2)*es_diff(3)) - es(2)*es(3)*((1-cosc)*ec_msh_diff(3)-
     +        ec_msh(3)*cosc_diff)
            ec(2) = temp0*ec_msh(2) - es(2)*sinc - es(2)*es(3)*((1-cosc)
     +        *ec_msh(3))
            temp0 = es(2)*es(2)*(-cosc+1) + cosc
            ec_diff(3) = ec_msh(3)*((1-cosc)*2*es(2)*es_diff(2)-(es(2)**
     +        2-1.0)*cosc_diff) + temp0*ec_msh_diff(3) - (1-cosc)*ec_msh
     +        (2)*(es(3)*es_diff(2)+es(2)*es_diff(3)) - es(2)*es(3)*((1-
     +        cosc)*ec_msh_diff(2)-ec_msh(2)*cosc_diff) - ec_msh(1)*(
     +        sinc*es_diff(3)+es(3)*sinc_diff) - es(3)*sinc*ec_msh_diff(
     +        1)
            ec(3) = temp0*ec_msh(3) - es(2)*es(3)*((1-cosc)*ec_msh(2)) -
     +        es(3)*sinc*ec_msh(1)
C
          ELSE
            ec_diff(1) = cosc_diff
            ec(1) = cosc
            ec_diff(2) = -(es(2)*sinc_diff+sinc*es_diff(2))
            ec(2) = -(sinc*es(2))
            ec_diff(3) = -(es(3)*sinc_diff+sinc*es_diff(3))
            ec(3) = -(sinc*es(3))
          END IF
C
C The derivative here also changes if we use a custom mesh
C Note the derivative is only wrt to AVL incidence vars
C as those are the vars AVL DVs can support
          DO n=1,ndesign
            IF (lsurfmsh(lssurf(j))) THEN
              ec_g(1, n) = (-(sinc*ec_msh(1))+es(2)*cosc*ec_msh(2)+es(3)
     +          *cosc*ec_msh(3))*ainc_g(j, n)
              ec_g(2, n) = (-(es(2)*cosc)+(es(3)**2*(1+sinc)-sinc)*
     +          ec_msh(2)-es(2)*es(3)*(1+sinc)*ec_msh(3))*ainc_g(j, n)
              ec_g(3, n) = (-(es(3)*cosc*ec_msh(1))-es(2)*es(3)*(1+sinc)
     +          *ec_msh(2)+(es(2)**2*(1+sinc)-sinc)*ec_msh(3))*ainc_g(j
     +          , n)
C
            ELSE
              ec_g(1, n) = -(sinc*ainc_g(j, n))
              ec_g(2, n) = -(cosc*es(2)*ainc_g(j, n))
              ec_g(3, n) = -(cosc*es(3)*ainc_g(j, n))
            END IF
          ENDDO
C
C...Normal vector is perpendicular to camberline vector and to the bound leg
          CALL CROSS_D(ec, ec_diff, eb, eb_diff, ecxb, ecxb_diff)
          arg10_diff = 2*ecxb(1)*ecxb_diff(1) + 2*ecxb(2)*ecxb_diff(2) +
     +      2*ecxb(3)*ecxb_diff(3)
          arg10 = ecxb(1)**2 + ecxb(2)**2 + ecxb(3)**2
          temp0 = SQRT(arg10)
          IF (arg10 .EQ. 0.D0) THEN
            emag_diff = 0.D0
          ELSE
            emag_diff = arg10_diff/(2.0*temp0)
          END IF
          emag = temp0
C This section is identical to the normal vector at the control
C point. The only different is that the AVL camberline slope 
C is taken at the bound vortex point rather than the control point
C the geometric contributions to the normal vector at both of these
C point is identical as the lie in the plane of the same panel.
          IF (emag .NE. 0.0) THEN
            temp0 = ecxb(1)/emag
            enc_diff(1, i) = (ecxb_diff(1)-temp0*emag_diff)/emag
            enc(1, i) = temp0
            temp0 = ecxb(2)/emag
            enc_diff(2, i) = (ecxb_diff(2)-temp0*emag_diff)/emag
            enc(2, i) = temp0
            temp0 = ecxb(3)/emag
            enc_diff(3, i) = (ecxb_diff(3)-temp0*emag_diff)/emag
            enc(3, i) = temp0
            DO n=1,ndesign
              CALL CROSS(ec_g(1, n), eb, ecxb_g)
              emag_g = enc(1, i)*ecxb_g(1) + enc(2, i)*ecxb_g(2) + enc(3
     +          , i)*ecxb_g(3)
              enc_g(1, i, n) = (ecxb_g(1)-enc(1, i)*emag_g)/emag
              enc_g(2, i, n) = (ecxb_g(2)-enc(2, i)*emag_g)/emag
              enc_g(3, i, n) = (ecxb_g(3)-enc(3, i)*emag_g)/emag
            ENDDO
          ELSE
            enc_diff(1, i) = es_diff(1)
            enc(1, i) = es(1)
            enc_diff(2, i) = es_diff(2)
            enc(2, i) = es(2)
            enc_diff(3, i) = es_diff(3)
            enc(3, i) = es(3)
          END IF
C
C
C...Define direction of normal vector at vortex mid-point. 
C   The YZ projection of the normal vector matches the camber slope
C   + section local incidence in the YZ defining plane for the section
          ang_diff = ainc_diff(j) - slopev_diff(i)/(1.0+slopev(i)**2)
          ang = ainc(j) - ATAN(slopev(i))
Cc          IF(LDES) THEN
C--------- add design-variable contribution to angle
          DO n=1,ndesign
            ang_diff = ang_diff + deldes(n)*ainc_g_diff(j, n)
            ang = ang + ainc_g(j, n)*deldes(n)
          ENDDO
Cc          ENDIF
C
          sinc_diff = COS(ang)*ang_diff
          sinc = SIN(ang)
          cosc_diff = -(SIN(ang)*ang_diff)
          cosc = COS(ang)
          IF (lsurfmsh(lssurf(j))) THEN
C direct mesh assignment branch
C see explanation in section above for control point normals
C ec_msh was already computed in that section
            ec_diff(1) = ec_msh(1)*cosc_diff + cosc*ec_msh_diff(1) + 
     +        ec_msh(2)*(sinc*es_diff(2)+es(2)*sinc_diff) + es(2)*sinc*
     +        ec_msh_diff(2) + ec_msh(3)*(sinc*es_diff(3)+es(3)*
     +        sinc_diff) + es(3)*sinc*ec_msh_diff(3)
            ec(1) = cosc*ec_msh(1) + es(2)*sinc*ec_msh(2) + es(3)*sinc*
     +        ec_msh(3)
            temp0 = es(3)*es(3)*(-cosc+1) + cosc
            ec_diff(2) = ec_msh(2)*((1-cosc)*2*es(3)*es_diff(3)-(es(3)**
     +        2-1.0)*cosc_diff) + temp0*ec_msh_diff(2) - sinc*es_diff(2)
     +        - es(2)*sinc_diff - (1-cosc)*ec_msh(3)*(es(3)*es_diff(2)+
     +        es(2)*es_diff(3)) - es(2)*es(3)*((1-cosc)*ec_msh_diff(3)-
     +        ec_msh(3)*cosc_diff)
            ec(2) = temp0*ec_msh(2) - es(2)*sinc - es(2)*es(3)*((1-cosc)
     +        *ec_msh(3))
            temp0 = es(2)*es(2)*(-cosc+1) + cosc
            ec_diff(3) = ec_msh(3)*((1-cosc)*2*es(2)*es_diff(2)-(es(2)**
     +        2-1.0)*cosc_diff) + temp0*ec_msh_diff(3) - (1-cosc)*ec_msh
     +        (2)*(es(3)*es_diff(2)+es(2)*es_diff(3)) - es(2)*es(3)*((1-
     +        cosc)*ec_msh_diff(2)-ec_msh(2)*cosc_diff) - ec_msh(1)*(
     +        sinc*es_diff(3)+es(3)*sinc_diff) - es(3)*sinc*ec_msh_diff(
     +        1)
            ec(3) = temp0*ec_msh(3) - es(2)*es(3)*((1-cosc)*ec_msh(2)) -
     +        es(3)*sinc*ec_msh(1)
C
          ELSE
            ec_diff(1) = cosc_diff
            ec(1) = cosc
            ec_diff(2) = -(es(2)*sinc_diff+sinc*es_diff(2))
            ec(2) = -(sinc*es(2))
            ec_diff(3) = -(es(3)*sinc_diff+sinc*es_diff(3))
            ec(3) = -(sinc*es(3))
          END IF
C
          DO n=1,ndesign
            IF (lsurfmsh(lssurf(j))) THEN
C Direct mesh assignment branch
              ec_g(1, n) = (-(sinc*ec_msh(1))+es(2)*cosc*ec_msh(2)+es(3)
     +          *cosc*ec_msh(3))*ainc_g(j, n)
              ec_g(2, n) = (-(es(2)*cosc)+(es(3)**2*(1+sinc)-sinc)*
     +          ec_msh(2)-es(2)*es(3)*(1+sinc)*ec_msh(3))*ainc_g(j, n)
              ec_g(3, n) = (-(es(3)*cosc*ec_msh(1))-es(2)*es(3)*(1+sinc)
     +          *ec_msh(2)+(es(2)**2*(1+sinc)-sinc)*ec_msh(3))*ainc_g(j
     +          , n)
C
            ELSE
              ec_g(1, n) = -(sinc*ainc_g(j, n))
              ec_g(2, n) = -(cosc*es(2)*ainc_g(j, n))
              ec_g(3, n) = -(cosc*es(3)*ainc_g(j, n))
            END IF
          ENDDO
C
C...Normal vector is perpendicular to camberline vector and to the bound leg
          CALL CROSS_D(ec, ec_diff, eb, eb_diff, ecxb, ecxb_diff)
          arg10_diff = 2*ecxb(1)*ecxb_diff(1) + 2*ecxb(2)*ecxb_diff(2) +
     +      2*ecxb(3)*ecxb_diff(3)
          arg10 = ecxb(1)**2 + ecxb(2)**2 + ecxb(3)**2
          temp0 = SQRT(arg10)
          IF (arg10 .EQ. 0.D0) THEN
            emag_diff = 0.D0
          ELSE
            emag_diff = arg10_diff/(2.0*temp0)
          END IF
          emag = temp0
C this is a pure rotation of the normal vector
C the geometric contribution from the mesh is already accounted for
          IF (emag .NE. 0.0) THEN
            temp0 = ecxb(1)/emag
            env_diff(1, i) = (ecxb_diff(1)-temp0*emag_diff)/emag
            env(1, i) = temp0
            temp0 = ecxb(2)/emag
            env_diff(2, i) = (ecxb_diff(2)-temp0*emag_diff)/emag
            env(2, i) = temp0
            temp0 = ecxb(3)/emag
            env_diff(3, i) = (ecxb_diff(3)-temp0*emag_diff)/emag
            env(3, i) = temp0
            DO n=1,ndesign
              CALL CROSS(ec_g(1, n), eb, ecxb_g)
              emag_g = enc(1, i)*ecxb_g(1) + enc(2, i)*ecxb_g(2) + enc(3
     +          , i)*ecxb_g(3)
              env_g(1, i, n) = (ecxb_g(1)-env(1, i)*emag_g)/emag
              env_g(2, i, n) = (ecxb_g(2)-env(2, i)*emag_g)/emag
              env_g(3, i, n) = (ecxb_g(3)-env(3, i)*emag_g)/emag
            ENDDO
          ELSE
            env_diff(1, i) = es_diff(1)
            env(1, i) = es(1)
            env_diff(2, i) = es_diff(2)
            env(2, i) = es(2)
            env_diff(3, i) = es_diff(3)
            env(3, i) = es(3)
          END IF
C
C
Ccc       write(*,*) i, dcontrol(i,1), dcontrol(i,2)
C
C=======================================================
C-------- rotate normal vectors for control surface
          DO n=1,ncontrol
C
C---------- skip everything if this element is unaffected by control variable N
            IF (dcontrol(i, n) .NE. 0.0) THEN
C
              ang = dtr*dcontrol(i, n)*delcon(n)
              ang_ddc_diff = dtr*dcontrol_diff(i, n)
              ang_ddc = dtr*dcontrol(i, n)
C
              cosd = COS(ang)
              sind = SIN(ang)
C
C---------- EP = normal-vector component perpendicular to hinge line
              endot_diff = DOT_D(enc(1, i), enc_diff(1, i), vhinge(1, j
     +          , n), vhinge_diff(1, j, n), endot)
              ep_diff(1) = enc_diff(1, i) - vhinge(1, j, n)*endot_diff -
     +          endot*vhinge_diff(1, j, n)
              ep(1) = enc(1, i) - endot*vhinge(1, j, n)
              ep_diff(2) = enc_diff(2, i) - vhinge(2, j, n)*endot_diff -
     +          endot*vhinge_diff(2, j, n)
              ep(2) = enc(2, i) - endot*vhinge(2, j, n)
              ep_diff(3) = enc_diff(3, i) - vhinge(3, j, n)*endot_diff -
     +          endot*vhinge_diff(3, j, n)
              ep(3) = enc(3, i) - endot*vhinge(3, j, n)
C---------- EQ = unit vector perpendicular to both EP and hinge line
              CALL CROSS_D(vhinge(1, j, n), vhinge_diff(1, j, n), ep, 
     +                     ep_diff, eq, eq_diff)
C
C---------- rotated vector would consist of sin,cos parts from EP and EQ,
C-          with hinge-parallel component ENDOT restored 
Cc          ENC(1,I) = EP(1)*COSD + EQ(1)*SIND + ENDOT*VHINGE(1,J,N)
Cc          ENC(2,I) = EP(2)*COSD + EQ(2)*SIND + ENDOT*VHINGE(2,J,N)
Cc          ENC(3,I) = EP(3)*COSD + EQ(3)*SIND + ENDOT*VHINGE(3,J,N)
C
C---------- linearize about zero deflection (COSD=1, SIND=0)
              enc_d_diff(1, i, n) = enc_d_diff(1, i, n) + ang_ddc*
     +          eq_diff(1) + eq(1)*ang_ddc_diff
              enc_d(1, i, n) = enc_d(1, i, n) + eq(1)*ang_ddc
              enc_d_diff(2, i, n) = enc_d_diff(2, i, n) + ang_ddc*
     +          eq_diff(2) + eq(2)*ang_ddc_diff
              enc_d(2, i, n) = enc_d(2, i, n) + eq(2)*ang_ddc
              enc_d_diff(3, i, n) = enc_d_diff(3, i, n) + ang_ddc*
     +          eq_diff(3) + eq(3)*ang_ddc_diff
              enc_d(3, i, n) = enc_d(3, i, n) + eq(3)*ang_ddc
C
C
C---------- repeat for ENV vector
C
C---------- EP = normal-vector component perpendicular to hinge line
              endot_diff = DOT_D(env(1, i), env_diff(1, i), vhinge(1, j
     +          , n), vhinge_diff(1, j, n), endot)
              ep_diff(1) = env_diff(1, i) - vhinge(1, j, n)*endot_diff -
     +          endot*vhinge_diff(1, j, n)
              ep(1) = env(1, i) - endot*vhinge(1, j, n)
              ep_diff(2) = env_diff(2, i) - vhinge(2, j, n)*endot_diff -
     +          endot*vhinge_diff(2, j, n)
              ep(2) = env(2, i) - endot*vhinge(2, j, n)
              ep_diff(3) = env_diff(3, i) - vhinge(3, j, n)*endot_diff -
     +          endot*vhinge_diff(3, j, n)
              ep(3) = env(3, i) - endot*vhinge(3, j, n)
C---------- EQ = unit vector perpendicular to both EP and hinge line
              CALL CROSS_D(vhinge(1, j, n), vhinge_diff(1, j, n), ep, 
     +                     ep_diff, eq, eq_diff)
C
C---------- rotated vector would consist of sin,cos parts from EP and EQ,
C-          with hinge-parallel component ENDOT restored 
Cc          ENV(1,I) = EP(1)*COSD + EQ(1)*SIND + ENDOT*VHINGE(1,J,N)
Cc          ENV(2,I) = EP(2)*COSD + EQ(2)*SIND + ENDOT*VHINGE(2,J,N)
Cc          ENV(3,I) = EP(3)*COSD + EQ(3)*SIND + ENDOT*VHINGE(3,J,N)
C
C---------- linearize about zero deflection (COSD=1, SIND=0)
              env_d(1, i, n) = env_d(1, i, n) + eq(1)*ang_ddc
              env_d(2, i, n) = env_d(2, i, n) + eq(2)*ang_ddc
              env_d(3, i, n) = env_d(3, i, n) + eq(3)*ang_ddc
            END IF
          ENDDO
        ENDDO
      ENDDO
C
C
      lenc = .true.
C
      RETURN
      END
C ENCALC

